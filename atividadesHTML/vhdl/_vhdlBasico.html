<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <style>
  /* fundo para o trecho de código */
  div.sourceCode { overflow-x: auto; background-color: rgb(250,250,250);}
  
  .bloco .title {
      display: block;
  }
  
  /*Bloco de solucao de exercicio*/
  .bloco .label,
  .bloco .separator {
      font-weight: bold;
  }
  
  .bloco .separator {
      margin-right: .6em;
  }
  /* Solução */
  div.solucao {
    border-left: .3em solid #dd4444;   /*#dc3c01; */
    margin-left: -.8em;
    padding-left: .4em;
    position: relative;
    font-size: 90%;
  }
  
  div.solucao .conteudo {
    display: none;
    padding-top: 1px;
  }
  
  div.solucao button {
    color: #0000AF;
    background-color: white;
    border-radius: 5px;
  }
  
  div.solucao button.viewed {
    color: #FF2020;
    background-color: white;
    border-radius: 5px;
  }
  
  /* Alinhamento dos títulos e parágrafos */
  
  body{margin-left: 5%; margin-right: 5%;
           color: black; background: white;}
  
  hr{
      margin-left: -4%;
      background-color: rgb(0,100,100);  /*anterior:    240,240,240 */
  }
  h1{
      margin-left: -4%;
      background-color: rgb(210,210,220);
  }
  
  h2{
      margin-left: -4%;
      background-color: rgb(220,220,230);
  }
  
  h3{
      margin-left: -4%;
      background-color: rgb(230,230,240);
  }
  
  h4{
      margin-left: -4%;
      background-color: rgb(240,240,250);
  }
  
  /* Cores */
  i{color: red}
  em{color: green}
  cite{color: brown}
  /* blockquote > p { */
  blockquote{color: red}
  blockquote p {
    margin-bottom: 0;
    font-size: 14px;
    font-weight: 300;
    line-height: 2em;
  }
  
  /* ---- Front Matter ----
  Pandoc header DIV. Contains .title, .author and .date. Comes before div#TOC.
  Only appears if one of those three are in the document.   */
  
  div#header, header
      {
      /* Put border on bottom. Separates it from TOC or body that comes after it. */
      border-bottom: 1px solid #aaa;
      margin-bottom: 0.5em;
      }
  
  .title /* Pandoc title header (h1.title) */
      {
      text-align: center;
      }
  
  .author, .date /* Pandoc author(s) and date headers (h2.author and h3.date) */
      {
      text-align: center;
      }
  
  /* Pandoc table of contents DIV when using the --toc option.
     NOTE: this doesn't support Pandoc's --id-prefix option for #TOC and #header.
     Probably would need to use div[id$='TOC'] and div[id$='header'] as selectors.
  */
  
  div#TOC, nav#TOC
      {
      /* Put border on bottom to separate it from body. */
      border-bottom: 1px solid #aaa;
      margin-bottom: 0.5em;
      }
  
  @media print
      {
      div#TOC, nav#TOC
          {
          /* Don't display TOC in print */
          display: none;
          }
      }
  /* ---- Images ---- */
  img
      {
      /* Let it be inline left/right where it wants to be, but verticality make
         it in the middle to look nicer, but opinions differ, and if in a multi-line
         paragraph, it might not be so great.
         vertical-align: middle;
      */
      vertical-align: middle;
      }
  div.figure /* Pandoc figure-style image */
      {
      /* Center the image and caption */
      margin-left: auto;
      margin-right: auto;
      text-align: center;
      font-style: italic;
      }
  p.caption /* Pandoc figure-style caption within div.figure */
      {
      /* Inherits div.figure props by default */
      }
  /*Tamanho absoluto das imagens definidas em markdown*/
  img[src*='#200'] {
    text-align: center;
    width: 200px;
  }
  img[src*='#400'] {
    text-align: center;
    width: 400px;
  }
  img[src*='#600'] {
    text-align: center;
    width: 600px;
  }
  img[src*='#800'] {
    text-align: center;
    width: 800px;
  }
  /*Tamanho relativo das imagens definidas em markdown*/
  img[src*='#p80'] {
    text-align: center;
    width: 80%;
  }
  img[src*='#p70'] {
    text-align: center;
    width: 70%;
  }
  img[src*='#p60'] {
    text-align: center;
    width: 60%;
  }
  img[src*='#p50'] {
    text-align: center;
    width: 50%;
  }
  img[src*='#p40'] {
    text-align: center;
    width: 40%;
  }
  img[src*='#p30'] {
    text-align: center;
    width: 30%;
  }
  img[src*='#p20'] {
    text-align: center;
    width: 20%;
  }
  img[src*='#p10'] {
    text-align: center;
    width: 10%;
  }
  /* ---- Tables ---- */
  table {
      margin-left: auto;
      margin-right: auto;
      margin-bottom: 24px;
      border-spacing: 0;
      border-bottom: 2px solid black;
      border-top: 2px solid black;
  }
  table th {
      padding: 3px 10px;
      background-color: white;
      border-top: 1px;
      border-left: 1px;
      border-right: 1px;
      border-bottom: 1px solid black;
  }
  table td {
      padding: 3px 10px;
      border-top: 1px;
      border-left: 1px;
      border-bottom: 1px;
      border-right: 1px;
  }
  /* fundo para as linhas das tabelas */
  tr.even{
    background-color: rgb(250,250,255);
  }
  tr.odd{
    background-color: rgb(250,250,250);
  }
  </style>
  <script type="text/javascript">
      function exibe(e)
      {
          var div = e.parentNode.firstElementChild;
  
          if (div.style.display == "" || div.style.display == "none") {
              div.style.display = "block";
              e.setAttribute("class", "viewed");
              e.innerHTML = "Esconder Solução";
          } else {
              div.style.display = "none";
              e.innerHTML = "Ver Solução";
          }
      }
  </script>
</head>
<body>
<p><a name="inicio"></a></p>
<h1 id="vhdl-básico">VHDL Básico</h1>
<blockquote>
<p><strong>Baseado no livro Free Range VHDL, de 2013, escrito por Bryan Mealy e Fabrizio Tappero.</strong></p>
<p><strong>E nos slides do curso de VHDL da Altera.</strong></p>
</blockquote>
<p><a href="#fimDocumento">Ir para o fim do documento</a>.</p>
<!--
**Conteúdo:**

-   [Regras de Ouro do VHDL](#regras-de-ouro-do-vhdl);
-   [Invariantes do VHDL](#invariantes-do-vhdl);
-   [Unidades de projeto](#unidades-de-projeto);
-   [Entidades](#entidades);
-   [Arquiteturas](#arquiteturas);
-   [Classes de Objetos](#classes-de-objetos);
-   [Tipos de dados](#tipos-de-dados);
-   [Estilos usados nas Arquiteturas](#estilos-usados-nas-arquiteturas);
    -   [Estilo Comportamental](#comportamental);
    -   [Estilo Fluxo de Dados](#fluxo-de-dados);
    -   [Estilo Estrutural](#estrutural).
-   [Instanciação de Componentes](#instanciação-de-componentes);
-   [Lista de palavras reservadas](#palavras-reservadas).

-->
<hr />
<h2 id="regras-de-ouro-do-vhdl">Regras de Ouro do VHDL:</h2>
<ul>
<li><p>VHDL é uma descrição, ou projeto, do hardware e não uma programação dele.</p>
<ul>
<li><p>As linhas de código não são executadas sequencialmente com exeção de algumas construções da linguagem.</p></li>
<li><p>As linhas de código serão executadas simultaneamente.</p></li>
</ul></li>
<li><p>Deve-se possuir uma visão de como o circuito final será.</p>
<ul>
<li>Se ele for muito complexo, use uma divisão em blocos menores até chegar às unidades construtivas básicas.</li>
</ul></li>
</ul>
<hr />
<h2 id="invariantes-do-vhdl">Invariantes do VHDL:</h2>
<ul>
<li><p>Não distingue maiúscas de minúsculas (case insensitive).</p></li>
<li><p>Não é sensível as espaços e tabulações.</p></li>
<li><p>Comentários iniciam com dois hifens: <strong>&quot;--&quot;</strong>.</p></li>
<li><p>O uso de parenteses nas operações é uma boa prática. Apesar de existir precedência entre as operações, o uso de parenteses aumenta a legibilidade.</p></li>
<li><p>Os comandos VHDL terminam com ponto e vírgula: <strong>&quot;;&quot;</strong>.</p></li>
<li><p>O comando <em>if</em> necessita que:</p>
<ul>
<li><p>Cada <em>if</em> tenha os seus comandos correspondentes: <em>then</em> e <em>end if;</em>.</p></li>
<li><p>No caso do <em>else if</em>, no VHDL, ele é chamado de: <em>elsif</em>.</p></li>
</ul></li>
<li><p>Os comandos <em>case</em> e <em>loop</em> possuem um comando de término:</p>
<ul>
<li>O <em>end case</em> e o <em>end loop</em>.</li>
</ul></li>
<li><p>Os identificadores são os nomes dados às variáveis, sinais, portas, entre outros.</p>
<ul>
<li><p>Eles não possuem limite de comprimento.</p></li>
<li><p>Esses nomes só podem utilizar uma combinação dos seguintes conjuntos de caracteres:</p>
<ul>
<li><p>Letras (A-Z e a-z);</p></li>
<li><p>Números (0-9);</p></li>
<li><p>O caractere de sublinhado: <strong>&quot;_&quot;</strong>.</p></li>
</ul></li>
<li><p>Os identificadores precisam iniciar com uma letra.</p></li>
<li><p>Eles não podem terminar com o caractere de sublinhado.</p></li>
<li><p>E não podem usar dois caracteres de sublinhado consecutivos.</p></li>
</ul></li>
<li><p>Existe um conjunto de <a href="#tabelaPalavrasReservadas">palavras reservadas</a> que não podem ser utilizadas como identificadores.</p></li>
</ul>
<hr />
<h2 id="unidades-de-projeto">Unidades de projeto:</h2>
<p>O VHDL utiliza uma abstração do tipo &quot;caixa-preta&quot; com uma estrutura hierárquica que permite:</p>
<ul>
<li><p>Agrupar unidades funcionais básicas para criar um circuito mais complexo e:</p>
<ul>
<li><p>Disponibilizar seu uso através de uma interface desse módulo;</p></li>
<li><p>Que esconde os detalhes do circuito que executa a funcionalidade desejada (a caixa-preta).</p></li>
</ul></li>
<li><p>A cada nível hierárquico agrupam-se:</p>
<ul>
<li><p>Mais módulos e cria-se um circuito cada vez mais complexo;</p></li>
<li><p>Que será disponibilizado, para o nível superior, através de uma nova interface de uso (ou seja, um novo módulo, mais complexo, composto de módulos mais simples).</p></li>
</ul></li>
<li><p>Variar a quantidade de detalhes disponíveis a cada nível hierárquico.</p></li>
</ul>
<p>Essa abordagem permite:</p>
<ul>
<li><p>Reutilizar o código criado anteriormente pelos projetistas;</p></li>
<li><p>Facilitar a compreenção do circuito através da análise da interligação dos módulos (nomeados adequadamente). O que é mais simples do que analisar o circuito com uma grande quantidade de portas lógicas interligadas.</p></li>
</ul>
<h3 id="principais-elementos-de-projeto">Principais elementos de projeto:</h3>
<p>Os principais elementos de projeto da linguagem VHDL são:</p>
<ul>
<li><p><a href="#entidades">Entidades</a> (<code>entity</code>):</p>
<ul>
<li>descreve os pinos de acesso à &quot;caixa-preta&quot;. Ou seja, a interface de uso do circuito.</li>
</ul></li>
<li><p><a href="#arquiteturas">Arquiteturas</a> (<code>architecture</code>):</p>
<ul>
<li>descreve o funcionamento interno do circuito.</li>
</ul></li>
<li><p><a href="">Configurações</a> (<code>configuration</code>):</p>
<ul>
<li>associa uma entidade com uma arquitetura, formando um circuito.</li>
</ul></li>
<li><p><a href="">Pacotes</a> (<code>package</code> e <code>package bodies</code>):</p>
<ul>
<li>é uma forma de armazenar modelos, definições, etc...</li>
</ul></li>
</ul>
<p>O VHDL possui dois pacotes embutidos (não precisam ser declarados):</p>
<ul>
<li><p>Standard;</p></li>
<li><p>TEXTIO.</p></li>
</ul>
<p><img src="../imagensVHDL/entidadeArquiteturaPCFS_2D.png" align="center" width="400"></p>
<hr />
<h4 id="bibliotecas">Bibliotecas:</h4>
<p>As definições básicas da linguagem (como os tipos, as funções de conversão entre os tipos, constantes matemáticas, funções aritméticas, entre outros recursos), estão contidas nas bibliotecas.</p>
<p>Uma biblioteca pode conter um ou mais pacotes. O VHDL possui duas bibliotecas implícitas (não precisam ser declaradas):</p>
<ul>
<li><p>Work: se refere aos módulos do projeto atual;</p></li>
<li><p>STD: contem os pacotes:</p>
<ul>
<li><p>standard, que define os tipos: bit, boolean integer, real e time.</p></li>
<li><p>textio: que define as operações com arquivos.</p></li>
</ul></li>
</ul>
<p>Para adicionar uma biblioteca precisamos de dois comandos:</p>
<ul>
<li><p>O <code>library</code>, que declara a biblioteca para ser utilizada:</p>
<ul>
<li>É um nome simbólico para o caminho (<code>path</code>) da biblioteca.</li>
</ul></li>
<li><p>O <code>use</code>, que especifica o pacote e objetos que existem na biblioteca definida com <code>library</code>.</p></li>
</ul>
<p>A biblioteca mais comum é a <code>IEEE</code>. E seus pacotes comumente usados são:</p>
<ul>
<li><p><code>ieee.std_logic_1164.all</code></p></li>
<li><p><code>ieee.numeric_std.all</code></p></li>
</ul>
<p>O exemplo abaixo mostra a utilização dos comandos <code>library</code> e <code>use</code>.</p>
<p>Os nomes entre os sinais <code>&lt;</code> e <code>&gt;</code>, incluindo os sinais, devem ser personalizados para a biblioteca e pacotes necessários à aplicação em desenvolvimento.</p>
<div class="sourceCode"><pre class="sourceCode vhdl"><code class="sourceCode vhdl"><span class="co">-- A library clause declares a name as a library.  It</span>
<span class="co">-- does not create the library; it simply forward declares it.</span>
<span class="kw">library</span> <span class="ot">&lt;</span>library_name<span class="ot">&gt;</span>;

<span class="co">-- Use clauses import declarations into the current scope.</span>
<span class="co">-- If more than one use clause imports the same name into the</span>
<span class="co">-- the same scope, none of the names are imported.</span>

<span class="co">-- Import all the declarations in a package</span>
<span class="kw">use</span> <span class="ot">&lt;</span>library_name<span class="ot">&gt;.&lt;</span>package_name<span class="ot">&gt;.</span>all;

<span class="co">-- Import a specific declaration from a package</span>
<span class="kw">use</span> <span class="ot">&lt;</span>library_name<span class="ot">&gt;.&lt;</span>package_name<span class="ot">&gt;.&lt;</span>object_name<span class="ot">&gt;</span>;

<span class="co">-- Import a specific entity from a library</span>
<span class="kw">use</span> <span class="ot">&lt;</span>library_name<span class="ot">&gt;.&lt;</span><span class="kw">entity_name</span><span class="ot">&gt;</span>;

<span class="co">-- Import from the work library.  The work library is an alias</span>
<span class="co">-- for the library containing the current design unit.</span>
use work<span class="ot">.&lt;</span>package_name<span class="ot">&gt;.</span><span class="kw">all</span>;

<span class="co">-- Commonly imported packages:</span>
  <span class="co">-- STD_LOGIC and STD_LOGIC_VECTOR types, and relevant functions</span>
  use ieee<span class="ot">.</span>std_logic_<span class="dv">1164</span><span class="ot">.</span><span class="kw">all</span>;

  <span class="co">-- SIGNED and UNSIGNED types, and relevant functions</span>
  use ieee<span class="ot">.</span>numeric_std<span class="ot">.</span><span class="kw">all</span>;</code></pre></div>
<h4 id="entidades">Entidades:</h4>
<p>Todo projeto deve possuir, no mínimo, uma entidade. Toda entidade deve possuir um nome. A entidade descreve a visão externa (interface) do circuito que a utiliza.</p>
<p>As entidades podem ser correlacionadas com o encapsulamento de um chip, onde temos os pinos de entrada, saída e eventualmente bidirecionais.</p>
<p>A construção mínima da entidade deve possuir uma seção declarativa, chamada de <code>port();</code>. Nela são definidos os nomes dos pinos, sua direção (modo), o tipo de dados relacionado a ele e, opcionalmente, um valor de inicialização. São os sinais que os circuitos externos a essa entidade utilizam para interagir com ela.</p>
<p>Além da seção <code>port();</code> pode existir uma seção chamada de <code>generic();</code>, onde são definidos parâmetros configuráveis em tempo de compilação.</p>
<p>Essa seção simula a passagem de argumentos que serão utilizados na compilação. Pode-se definir, por exemplo, o número de <em>bits</em> utilizados como entrada ou saída daquele módulo.</p>
<p>Em tempo de execução a parametrização não pode ser alterada, já que os circuitos foram criados durante a compilação. Lembre que estamos criando circuitos e não executando uma rotina de programa.</p>
<p>Os <a href="#tiposDados">tipos de dados</a> que existem na linguagem VHDL estão definidos em uma seção mais à frente.</p>
<p><br></p>
<p><strong>Estrutura básica:</strong></p>
<p>O modelo geral de uma entidade está mostrado abaixo (retirada do Quartus Prime Lite). Note que alguns trechos são opcionais, como o <code>generic</code> e os valores de inicialização.</p>
<div class="sourceCode"><pre class="sourceCode vhdl"><code class="sourceCode vhdl"><span class="kw">entity</span> <span class="ot">&lt;</span><span class="kw">entity_name</span><span class="ot">&gt;</span> <span class="kw">is</span>
  <span class="kw">generic</span>
  (
    <span class="co">-- O generic é opcional.</span>
  <span class="ot">&lt;</span>name<span class="ot">&gt;</span>    <span class="ot">:</span> <span class="ot">&lt;type&gt;</span>  <span class="ot">:=</span>    <span class="ot">&lt;</span>default_value<span class="ot">&gt;</span>;
  <span class="ot">&lt;</span>name<span class="ot">&gt;</span>    <span class="ot">:</span> <span class="ot">&lt;type&gt;</span>  <span class="ot">:=</span>    <span class="ot">&lt;</span>default_value<span class="ot">&gt;</span>
  );
  <span class="kw">port</span>    <span class="co">-- O port é obrigatório e possui o objeto “signal” implícito.</span>
  (
  <span class="co">-- Input ports</span>
    <span class="co">-- &quot;in&quot; indica que é uma porta no modo de entrada.</span>
    <span class="co">-- O valor de inicialização é opcional.</span>
  <span class="ot">&lt;</span>name<span class="ot">&gt;</span>    <span class="ot">:</span> <span class="kw">in</span>  <span class="ot">&lt;type&gt;</span>;
  <span class="ot">&lt;</span>name<span class="ot">&gt;</span>    <span class="ot">:</span> <span class="kw">in</span>  <span class="ot">&lt;type&gt;</span> <span class="ot">:=</span> <span class="ot">&lt;</span>default_value<span class="ot">&gt;</span>;

  <span class="co">-- Inout ports</span>
    <span class="co">-- &quot;inout&quot; indica que é uma porta no modo bidirecional.</span>
    <span class="co">-- Não existe valor de inicialização.</span>
  <span class="ot">&lt;</span>name<span class="ot">&gt;</span>    <span class="ot">:</span> <span class="kw">inout</span> <span class="ot">&lt;type&gt;</span>;

  <span class="co">-- Output ports</span>
    <span class="co">-- &quot;out&quot; indica que é uma porta no modo de saída.</span>
    <span class="co">-- O valor de inicialização é opcional.</span>
  <span class="ot">&lt;</span>name<span class="ot">&gt;</span>    <span class="ot">:</span> <span class="kw">out</span> <span class="ot">&lt;type&gt;</span>;
  <span class="ot">&lt;</span>name<span class="ot">&gt;</span>    <span class="ot">:</span> <span class="kw">out</span> <span class="ot">&lt;type&gt;</span> <span class="ot">:=</span> <span class="ot">&lt;</span>default_value<span class="ot">&gt;</span>

  <span class="co">-- Buffer ports</span>
  <span class="co">-- Similar a Out, mas permite realimentação interna.</span>
  <span class="ot">&lt;</span>name<span class="ot">&gt;</span>  <span class="ot">:</span> <span class="kw">buffer</span>  <span class="ot">&lt;type&gt;</span>;
  );
<span class="kw">end</span> <span class="ot">&lt;</span>entity_name<span class="ot">&gt;</span>;   <span class="co">-- Também pode ser utilizado: &quot;end entity&quot;;</span></code></pre></div>
<p><br><br></p>
<p><strong>Exemplos:</strong></p>
<p>Abaixo temos um exemplo do modelo, disponível no Quartus Prime Lite, de um somador configurável através de <code>generic</code>:</p>
<div class="sourceCode"><pre class="sourceCode vhdl"><code class="sourceCode vhdl">
<span class="co">-- Quartus Prime VHDL Template</span>
<span class="co">-- Signed Adder</span>

<span class="kw">library</span> ieee;
<span class="kw">use</span> ieee<span class="ot">.</span>std_logic_1164<span class="ot">.</span>all;
<span class="kw">use</span> ieee<span class="ot">.</span>numeric_std<span class="ot">.</span>all;

<span class="kw">entity</span> <span class="kw">signed_adder</span> <span class="kw">is</span>
  <span class="kw">generic</span>
  (
        DATA_WIDTH <span class="ot">:</span> <span class="dt">natural</span> <span class="ot">:=</span> <span class="dv">8</span>
  );
  <span class="kw">port</span>
  (
            a      <span class="ot">:</span> <span class="kw">in</span> <span class="dt">signed</span>  ((DATA_WIDTH<span class="ot">-</span><span class="dv">1</span>) <span class="ot">downto</span> <span class="dv">0</span>);
            b      <span class="ot">:</span> <span class="kw">in</span> <span class="dt">signed</span>  ((DATA_WIDTH<span class="ot">-</span><span class="dv">1</span>) <span class="ot">downto</span> <span class="dv">0</span>);
            result <span class="ot">:</span> <span class="kw">out</span> <span class="dt">signed</span> ((DATA_WIDTH<span class="ot">-</span><span class="dv">1</span>) <span class="ot">downto</span> <span class="dv">0</span>)
  );

<span class="kw">end entity;</span>

<span class="kw">architecture</span> <span class="kw">rtl</span> <span class="kw">of</span> <span class="kw">signed_adder</span> <span class="kw">is</span>
<span class="kw">begin</span>
         result <span class="ot">&lt;=</span> a <span class="ot">+</span> b;
<span class="er">end architecture;</span></code></pre></div>
<p>Na instanciação do componente existe a opção de alterar o valor do <code>generic</code>. Se o valor não for alterado, será criado um somador de 8 bits (como foi definido na entidade). Para saber como instanciar um módulo e alterar o <code>generic</code>, veja a <a href="#instanciar">seção sobre instanciação</a>.</p>
<p>Abaixo, temos outro exemplo de entidade usando o <code>generic</code>. Note que é possível fazer aritmética com o valor do <code>generic</code> para definir a largura de dados dos <code>ports</code>.</p>
<div class="sourceCode"><pre class="sourceCode vhdl"><code class="sourceCode vhdl"><span class="co">-- Quartus Prime VHDL Template</span>
<span class="co">-- Unsigned Multiply</span>

<span class="kw">library</span> ieee;
<span class="kw">use</span> ieee<span class="ot">.</span>std_logic_1164<span class="ot">.</span>all;
<span class="kw">use</span> ieee<span class="ot">.</span>numeric_std<span class="ot">.</span>all;

<span class="kw">entity</span> <span class="kw">unsigned_multiply</span> <span class="kw">is</span>
  <span class="kw">generic</span>
  (
        DATA_WIDTH <span class="ot">:</span> <span class="dt">natural</span> <span class="ot">:=</span> <span class="dv">8</span>
  );
  <span class="kw">port</span>
  (
            a      <span class="ot">:</span> <span class="kw">in</span> <span class="dt">unsigned</span> ((DATA_WIDTH<span class="ot">-</span><span class="dv">1</span>) <span class="ot">downto</span> <span class="dv">0</span>);
            b      <span class="ot">:</span> <span class="kw">in</span> <span class="dt">unsigned</span> ((DATA_WIDTH<span class="ot">-</span><span class="dv">1</span>) <span class="ot">downto</span> <span class="dv">0</span>);
            result  <span class="ot">:</span> <span class="kw">out</span> <span class="dt">unsigned</span> ((<span class="dv">2</span><span class="ot">*</span>DATA_WIDTH<span class="ot">-</span><span class="dv">1</span>) <span class="ot">downto</span> <span class="dv">0</span>)
  );

<span class="kw">end entity;</span>

<span class="kw">architecture</span> <span class="kw">rtl</span> <span class="kw">of</span> <span class="kw">unsigned_multiply</span> <span class="kw">is</span>
<span class="kw">begin</span>
         result <span class="ot">&lt;=</span> a <span class="ot">*</span> b;
<span class="er">end architecture;</span></code></pre></div>
<p><br></p>
<hr />
<h4 id="arquiteturas">Arquiteturas:</h4>
<p>Toda entidade deve possuir, ao menos, uma arquitetura. Ela deve descrever o funcionamento interno do circuito associado à entidade. Para uma mesma entidade, pode-se ter arquiteturas diferentes, que descrevem circuitos de forma diferente ou com funcionalidade diferente.</p>
<p>Uma mesma arquitetura pode ser modelada com estilos diferentes. Esses estilos são:</p>
<ul>
<li><p><a href="#fluxo-de-dados">Data-Flow (fluxo de dados):</a></p>
<ul>
<li>Um conjunto de comandos concorrentes que representam o fluxo dos dados pelo circuito.</li>
</ul></li>
<li><p><a href="#comportamental">Behavioral (comportamental):</a></p>
<ul>
<li><p>Um conjunto de comandos concorrentes que representam o comportamento da entidade;</p></li>
<li><p>Um conjunto de comandos sequenciais que representam o comportamento da entidade.</p></li>
</ul></li>
<li><p><a href="#estrutural">Structural (estrutural):</a></p>
<ul>
<li>Um conjunto de componentes interconectados que representam a estrutura da entidade.</li>
</ul></li>
<li><p>Híbrido:</p>
<ul>
<li>Uma mistura dos modelos acima.</li>
</ul></li>
</ul>
<p>Abaixo temos um modelo geral de uma arquitetura (retirada do Quartus Prime Lite). Note que existem vários comandos opcionais.</p>
<div class="sourceCode"><pre class="sourceCode vhdl"><code class="sourceCode vhdl"><span class="co">-- Library Clause(s) (optional)</span>
<span class="co">-- Use Clause(s) (optional)</span>

architecture <span class="ot">&lt;</span>arch_name<span class="ot">&gt;</span> of <span class="ot">&lt;</span><span class="kw">entity_name</span><span class="ot">&gt;</span> <span class="kw">is</span>

  <span class="co">-- Área reservada para declarações.</span>
  <span class="co">-- Declarations (optional)</span>

<span class="kw">begin</span>

  <span class="co">-- Descrição do funcionamento do circuito.</span>
  <span class="co">-- Pode utilizar os seguintes comandos:</span>

  <span class="co">-- Process Statement (optional)   -- podem existir vários</span>

  <span class="co">-- Concurrent Procedure Call (optional)</span>

  <span class="co">-- Concurrent Signal Assignment (optional)</span>

  <span class="co">-- Conditional Signal Assignment (optional)</span>

  <span class="co">-- Selected Signal Assignment (optional)</span>

  <span class="co">-- Component Instantiation Statement (optional)</span>

  <span class="co">-- Generate Statement (optional)</span>

<span class="er">end architecture;</span></code></pre></div>
<p>Entre a definição da arquitetura e o <code>begin</code>, temos a área reservada para declarações (caso existam).</p>
<p>Em seguida, entre o <code>begin</code> e o <code>end</code>, temos a área reservada para a descrição do funcionamento do circuito.</p>
<p>Os detalhes sobre os grupos de declarações, que podem ser utilizados na descrição do funcionamento, está disponível na seção <a href="#paradigma-de-programação-vhdl">Paradigma de Programação VHDL</a>.</p>
<p><br></p>
<p><strong>Exemplos:</strong></p>
<p>Abaixo temos uma entidade com 2 pinos de entrada e um de saída. Note que essa entidade pode ser utilizada com diferentes funções: AND, OR e XOR. A arquitetura a ser utilizada pode ser configurada com o comando <code>configuration</code> ou no momento da instaciação.</p>
<div class="sourceCode"><pre class="sourceCode vhdl"><code class="sourceCode vhdl"><span class="co">-- Quartus Prime VHDL Template</span>
<span class="co">-- Configurable gate architecture</span>

<span class="kw">library</span> ieee;
<span class="kw">use</span> ieee<span class="ot">.</span>std_logic_1164<span class="ot">.</span>all;
<span class="kw">entity</span> <span class="kw">configurable_gate</span> <span class="kw">is</span>
  <span class="kw">port</span>
  (
        i1 <span class="ot">:</span> <span class="kw">in</span> <span class="dt">std_logic</span>;
        i2 <span class="ot">:</span> <span class="kw">in</span> <span class="dt">std_logic</span>;
        o1 <span class="ot">:</span> <span class="kw">out</span> <span class="dt">std_logic</span>
  );
<span class="er">end configurable_gate;</span>

<span class="co">-- Three possible architectures</span>
<span class="kw">architecture</span> <span class="kw">and_gate</span> <span class="kw">of</span> <span class="kw">configurable_gate</span> <span class="kw">is</span>
<span class="kw">begin</span>
        o1 <span class="ot">&lt;=</span> i1 <span class="kw">AND</span> i2;
<span class="er">end and_gate;</span>

<span class="kw">architecture</span> <span class="kw">or_gate</span> <span class="kw">of</span> <span class="kw">configurable_gate</span> <span class="kw">is</span>
<span class="kw">begin</span>
        o1 <span class="ot">&lt;=</span> i1 <span class="kw">OR</span> i2;
<span class="er">end or_gate;</span>

<span class="kw">architecture</span> <span class="kw">xor_gate</span> <span class="kw">of</span> <span class="kw">configurable_gate</span> <span class="kw">is</span>
<span class="kw">begin</span>
        o1 <span class="ot">&lt;=</span> i1 <span class="kw">XOR</span> i2;
<span class="er">end xor_gate;</span></code></pre></div>
<hr />
<p><a name="classesObjetos"></a></p>
<h4 id="classes-de-objetos">Classes de Objetos</h4>
<p>Em VHDL, os objetos são uma representação abstrata de dados armazenados. Existem quatro classes de objetos:</p>
<ul>
<li><p>A classe <code>variable</code> é usada para armazenar informações locais:</p>
<ul>
<li>Seu valor é alterado no momento da atribuição. É utilizada em trechos de código que possuem execução sequencial.</li>
</ul></li>
<li><p>A classe <code>constant</code> é similar a uma <code>variable</code> mas seu valor é imutável após a atribuição inicial.</p></li>
<li><p>A classe <code>signal</code> é usada para transferir valores entre os elementos do projeto ou para fora deste (como um fio):</p>
<ul>
<li>Pode ser usada em trechos de código sequencial ou concorrente. Seu valor pode ser alterado mas a mudança ocorre somente depois do término do <code>process</code>que a contem.</li>
</ul></li>
<li><p>A classe <code>file</code> é usada para armazenar dados de forma persistente:</p>
<ul>
<li>A principal aplicação é na simulação, onde pode salvar resultados ou carregar vetores de teste.</li>
</ul></li>
</ul>
<p>Ao criar os objetos dessas classes, deve-se associar cada objeto a um tipo de dados. A sintaxe geral é vista abaixo:</p>
<p><img src="../imagensVHDL/classeObjetoTipo-1.png" align="center" width="400"></p>
<p><br></p>
<p>Existe uma excessão a essa sintaxe. Ela ocorre dentro da entidade, onde a definição do <code>port</code> não define o seu objeto. Nesse caso, o objeto <code>signal</code> está implícito.</p>
<p>É obrigatório declarar um objeto do tipo <code>signal</code> ou <code>variable</code> antes de usá-los:</p>
<ul>
<li><p>Os sinais são declarados no topo do corpo da arquitetura, logo antes do <code>begin</code>;</p></li>
<li><p>As variáveis devem ser declaradas dentro do <code>process</code>.</p></li>
</ul>
<p>Sinais declarados na arquitetura são chamados de sinais intermediários e não possuem declaração de modo (<code>in</code>, <code>out</code> ou <code>inout</code>).</p>
<p>A atribuição de um novo valor a um objeto <code>signal</code> deve ser feita com o operador de atribuição, que possui um <code>process</code> implicito:</p>
<ul>
<li>&lt;=</li>
</ul>
<p>Para um objeto do tipo <code>variable</code>, deve-se utilizar outro operador de atribuição:</p>
<ul>
<li>:=</li>
</ul>
<p>As atribuições podem ser por agregados:</p>
<ul>
<li>Onde se atribui, separadamente, valores a cada elemento do vetor.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode vhd"><code class="sourceCode vhdl">constant valeZero <span class="ot">:</span> BIT <span class="ot">:=</span> ‘0’;
constant valeUm   <span class="ot">:</span> BIT <span class="ot">:=</span> ‘1’;

vetor1<span class="ot">,</span> vetor2<span class="ot">,</span> vetor3 <span class="ot">:</span>   OUT   bit_vector(4 downto 0);
Vetor1 <span class="ot">&lt;=</span> “01011”;                                        <span class="co">-- Atribuição direta</span>
vetor2 <span class="ot">&lt;=</span> valeZero <span class="ot">&amp;</span> <span class="st">&quot;01&quot;</span> <span class="ot">&amp;</span> vetor1(2) <span class="ot">&amp;</span> valeUm;           <span class="co">-- Concatenação</span>
vetor3 (4 downto 2) <span class="ot">&lt;=</span> “010”;                             <span class="co">-- Atribuição parcial</span>
vetor3 (1 downto 0) <span class="ot">&lt;=</span> vetor1 (2 TO 3);                   <span class="co">-- Atribuição parcial</span>

vetor1  <span class="ot">&lt;=</span> (‘0’<span class="ot">,</span>’1’<span class="ot">,</span>’0’<span class="ot">,</span>’1’<span class="ot">,</span>’1’);                         <span class="co">-- Atribuição agregados posicional</span>
vetor2 <span class="ot">&lt;=</span> (1 <span class="ot">=&gt;</span> ‘1’<span class="ot">,</span> OTHERS <span class="ot">=&gt;</span> ‘0’);                      <span class="co">-- Atribuição agregados posicional e valor padrão para o restante</span>
vetor3 <span class="ot">&lt;=</span> (valeZero<span class="ot">,</span> vetor2(3)<span class="ot">,</span> valeUm OR vetor1(0)<span class="ot">,</span> ‘0’<span class="ot">,</span> ’0’);
vetor2 (4 downto 3 <span class="ot">=&gt;</span> “00”<span class="ot">,</span> 1 <span class="ot">=&gt;</span> ‘1’<span class="ot">,</span> OTHERS <span class="ot">=&gt;</span> ‘0’);</code></pre></div>
<p>A diferença entre <code>variables</code> e <code>signals</code> está no momento da mudança de seu valor.</p>
<p>Uma variável muda seu valor logo após a atribuição ser executada, estando disponível para o comando da próxima linha.</p>
<p>Ao contrário, um sinal só muda o seu valor após o término do <code>process</code> em que houve a atribuição. Ou seja, seu novo valor só estará disponível para o código na linha seguinte ao <code>end process</code>. Lembrando que a atribuição em trechos concorrentes está automaticamente embutida em um <code>process</code> e sua disponibilidade será para o fim do <code>process</code>, ou seja, para a próxima linha.</p>
<p>A variável representa informação local e só pode ser usada dentro de código sequencial (dentro da construção <code>process</code>). Ela é geralmente utilizada para descrever o comportamento.</p>
<p>A transferência do valor de uma variável para fora de seu módulo não pode ser feita diretamente. É necessário, primeiro, atribuí-la a um <em>signal</em>.</p>
<h4 id="escopo-dos-objetos">Escopo dos Objetos</h4>
<p>A visibilidade desses objetos está relacionada ao lugar onde eles foram declarados:</p>
<ul>
<li><p>Declarações feitas dentro de um pacote:</p>
<ul>
<li>São acessíveis a todas as entidades que usam aquele pacote.</li>
</ul></li>
<li><p>Declarações feitas dentro de uma entidade:</p>
<ul>
<li>São acessíveis a todas as arquiteturas que usam aquela entidade.</li>
</ul></li>
<li><p>Declarações feitas dentro de uma arquitetura:</p>
<ul>
<li>São acessíveis a todas as sentenças dentro daquela arquitetura.</li>
</ul></li>
<li><p>Declarações feitas dentro de um processo:</p>
<ul>
<li>São acessíveis somente dentro daquele processo.</li>
</ul></li>
</ul>
<!--
```
<Classe do objeto> <nome/identificador do objeto>: <tipo de dado> [:=valor inicial];
```
-->
<p><a name="tiposDados"></a></p>
<h3 id="tipos-de-dados">Tipos de Dados:</h3>
<p>O VHDL é uma linguagem fortemente tipada e nela existem três categorias de tipos de dados:</p>
<ol style="list-style-type: decimal">
<li><p>Tipos escalares (<code>scalar</code>): seus valores possuem uma ordem sequencial.</p></li>
<li><p>Tipos compostos: podem ser compostos de elementos:</p>
<ul>
<li><p>de um único tipo, caracterizando um arranjo (<code>array type</code>);</p></li>
<li><p>de tipos diferentes, caracterizando um registro (<code>record type</code>).</p></li>
</ul></li>
<li><p>Tipos de acesso: permitem o acesso a objetos de um dado tipo através de ponteiros (<code>pointers</code>).</p></li>
</ol>
<p>Cada tipo de dados define:</p>
<ul>
<li><p>Um conjunto de valores que esses objetos podem assumir;</p></li>
<li><p>E um conjunto de operações que podem ser executadas com os objetos desse tipo.</p></li>
</ul>
<p>Ou seja, um objeto de certo tipo não pode receber valores de outro tipo de objeto:</p>
<ul>
<li>Deve ser feita a <a href="#convTipos">conversão de tipos</a>.</li>
</ul>
<p><img src="../imagensVHDL/tiposDadosVHDLptbr-svg.png" alt="Tipos de Dados em VHDL" style="width:600px;"/></p>
<p>Além dos tipos de dados predefinidos, o programador pode criar novos tipos e subtipos de dados. Em geral, esses novos tipos estão disponíveis em pacotes ou bibliotecas VHDL.</p>
<p>O pacote <code>standard</code> da biblioteca <code>std</code>, que é incluído por padrão, possui os seguintes tipos predefinidos:</p>
<ul>
<li><code>bit</code>: é um tipo com dois valores ('0' ou '1').</li>
<li><code>bit_vector</code>: um <code>array</code> de <code>bit</code>. No seu lugar, é mais usado o <code>std_logic_vector</code>.</li>
<li><code>boolean</code>: um tipo enumerado com dois valores (<code>true</code> ou <code>false</code>).</li>
<li><code>integer</code>: valores decimais inteiros, tanto positivos quanto negativos.</li>
<li><code>natural</code>: é um subtipo de <code>integer</code> onde não existem os números negativos.</li>
<li><code>positive</code>: é um subtipo de <code>integer</code> onde não existe o zero e os números negativos.</li>
<li><code>integer_vector</code>: é um vetor composto somente com tipos <code>integer</code>.</li>
<li><code>character</code>: é um tipo enumerado com 256 símbolos.</li>
<li><code>string</code>: é um vetor composto somente com tipos <code>character</code>.</li>
<li><code>real</code>: valores decimais fracionários.</li>
<li><code>time</code>: valores inteiros definindo unidades de tempo.</li>
</ul>
<p>A biblioteca do IEEE possui o pacote O tipo <code>std_logic_1164</code>, que define os tipos:</p>
<ul>
<li><code>std_logic</code>: tipo resolvido que possui 9 valores. Suporta múltiplos sinais acionando um único sinal;</li>
<li><code>std_logic_vector</code>: é um vetor composto somente com tipos <code>std_logic</code>.</li>
<li><code>std_ulogic</code>: possui os mesmos 9 valores, porém não é resolvido. Não suporta múltiplos sinais acionando um único sinal, ocorrerá um erro.</li>
<li><code>std_ulogic_vector</code>: é um vetor composto somente com tipos <code>std_ulogic</code>.</li>
</ul>
<p>O uso do tipo <code>std_logic</code> suplantou o tipo <code>bit</code>.</p>
<div class="sourceCode"><pre class="sourceCode vhdl"><code class="sourceCode vhdl">    type my_count is range 0 to 100;     <span class="co">-- user-defined type</span>
    constant max_count <span class="ot">:</span> my_count <span class="ot">:=</span> 31; <span class="co">-- user-defined constant</span>
    signal tmp_sclk <span class="ot">:</span> std_logic;         <span class="co">-- intermediate signal</span></code></pre></div>
<h4 id="tipo-de-dados-enumerado">Tipo de Dados: Enumerado</h4>
<p>É formado por uma faixa de valores definida pelo usuário. TYPE <nome_tipo_dados> IS (itens ou valores permitidos para o seu tipo de dados, separados por virgula)</p>
<div class="sourceCode"><pre class="sourceCode vhdl"><code class="sourceCode vhdl">type estado is (ST0<span class="ot">,</span>ST1<span class="ot">,</span>ST2<span class="ot">,</span>ST3);</code></pre></div>
<p>O tipo <code>std_logic</code> é um tipo enumerado, como mostra a sua definição:</p>
<div class="sourceCode"><pre class="sourceCode vhdl"><code class="sourceCode vhdl">type std_logic is ( <span class="bn">&#39;U&#39;</span><span class="ot">,</span>  <span class="co">-- uninitialised</span>
                    <span class="bn">&#39;X&#39;</span><span class="ot">,</span>  <span class="co">-- forcing unknown</span>
                    <span class="bn">&#39;0&#39;</span><span class="ot">,</span>  <span class="co">-- forcing 0</span>
                    <span class="bn">&#39;1&#39;</span><span class="ot">,</span>  <span class="co">-- forcing 1</span>
                    <span class="bn">&#39;Z&#39;</span><span class="ot">,</span>  <span class="co">-- high impedance</span>
                    <span class="bn">&#39;W&#39;</span><span class="ot">,</span>  <span class="co">-- weak unknown</span>
                    <span class="bn">&#39;L&#39;</span><span class="ot">,</span>  <span class="co">-- weak 0</span>
                    <span class="bn">&#39;H&#39;</span><span class="ot">,</span>  <span class="co">-- weak 1</span>
                    <span class="bn">&#39;-&#39;</span>   <span class="co">-- unspecified (do not care)</span>
);</code></pre></div>
<p>Isso permite que ele cubra situações, durante as simulações, onde dois sinais, um com nível lógico alto e outro com nível baixo, excitem uma entrada. O resultado é obtido através de uma tabela de resolução:</p>
<table>
<thead>
<tr class="header">
<th>U</th>
<th>X</th>
<th>0</th>
<th>1</th>
<th>Z</th>
<th>W</th>
<th>L</th>
<th>H</th>
<th>'--'</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>'U'</td>
<td>'U'</td>
<td>'U'</td>
<td>'U'</td>
<td>'U'</td>
<td>'U'</td>
<td>'U'</td>
<td>'U'</td>
<td>'U'</td>
<td>--</td>
<td><strong>U</strong></td>
</tr>
<tr class="even">
<td>'U'</td>
<td>'X'</td>
<td>'X'</td>
<td>'X'</td>
<td>'X'</td>
<td>'X'</td>
<td>'X'</td>
<td>'X'</td>
<td>'X'</td>
<td>--</td>
<td><strong>X</strong></td>
</tr>
<tr class="odd">
<td>'U'</td>
<td>'X'</td>
<td>'0'</td>
<td>'X'</td>
<td>'0'</td>
<td>'0'</td>
<td>'0'</td>
<td>'0'</td>
<td>'X'</td>
<td>--</td>
<td><strong>0</strong></td>
</tr>
<tr class="even">
<td>'U'</td>
<td>'X'</td>
<td>'X'</td>
<td>'1'</td>
<td>'1'</td>
<td>'1'</td>
<td>'1'</td>
<td>'1'</td>
<td>'X'</td>
<td>--</td>
<td><strong>1</strong></td>
</tr>
<tr class="odd">
<td>'U'</td>
<td>'X'</td>
<td>'0'</td>
<td>'1'</td>
<td>'Z'</td>
<td>'W'</td>
<td>'L'</td>
<td>'H'</td>
<td>'X'</td>
<td>--</td>
<td><strong>Z</strong></td>
</tr>
<tr class="even">
<td>'U'</td>
<td>'X'</td>
<td>'0'</td>
<td>'1'</td>
<td>'W'</td>
<td>'W'</td>
<td>'W'</td>
<td>'W'</td>
<td>'X'</td>
<td>--</td>
<td><strong>W</strong></td>
</tr>
<tr class="odd">
<td>'U'</td>
<td>'X'</td>
<td>'0'</td>
<td>'1'</td>
<td>'L'</td>
<td>'W'</td>
<td>'L'</td>
<td>'W'</td>
<td>'X'</td>
<td>--</td>
<td><strong>L</strong></td>
</tr>
<tr class="even">
<td>'U'</td>
<td>'X'</td>
<td>'0'</td>
<td>'1'</td>
<td>'H'</td>
<td>'W'</td>
<td>'W'</td>
<td>'H'</td>
<td>'X'</td>
<td>--</td>
<td><strong>H</strong></td>
</tr>
<tr class="odd">
<td>'U'</td>
<td>'X'</td>
<td>'X'</td>
<td>'X'</td>
<td>'X'</td>
<td>'X'</td>
<td>'X'</td>
<td>'X'</td>
<td>'X'</td>
<td>--</td>
<td><strong>'--'</strong></td>
</tr>
</tbody>
</table>
<h4 id="subtipos">Subtipos</h4>
<p>Subtipos são tipos predefinidos:</p>
<ul>
<li><p>Aos quais é aplicada uma restrição de faixa de valores;</p></li>
<li><p>Qualquer atribuição de valor, fora dessa faixa, gera um erro.</p></li>
</ul>
<div class="sourceCode"><pre class="sourceCode vhdl"><code class="sourceCode vhdl">SUBTYPE <span class="ot">&lt;</span>name<span class="ot">&gt;</span> IS <span class="ot">&lt;</span>base type<span class="ot">&gt;</span> RANGE <span class="ot">&lt;</span>user range<span class="ot">&gt;</span>;

SUBTYPE first_ten IS integer RANGE 1 to 10;
SUBTYPE byte IS bit_vector(7 downto 0);  <span class="co">-- little endian</span>
SUBTYPE byte IS bit_vector(0 to 7);      <span class="co">-- big endian</span></code></pre></div>
<hr />
<p><a name="convTipos"></a></p>
<h4 id="conversão-de-tipos">Conversão de Tipos</h4>
<p>Como o VHDL é uma linguagem fortemente tipada, para fazer operações com objetos de diferentes tipos, temos que fazer a conversão de tipos desses objetos. Ela pode ser feita através de <code>type cast</code> ou através de funções de conversão. A figura abaixo mostra as formas de fazer as conversões e os casos em que aplicamos cada uma.</p>
<p><img src="../imagensVHDL/vhdl-type-conversionsPCFS.svg" alt="Conversão de Tipos" style="width:600px;"/></p>
<p>O uso de um vetor, como o <code>std_logic_vector</code>, não define o significado de seus componentes. Ou seja, ele só define que existe um grupo de sinais juntos. Dessa forma, para fazer operações com esses vetores é necessário convertê-los em tipos com ou sem sinal (<code>signed</code>, <code>unsigned</code>, ou <code>integer</code>). Essa conversão permite que o grupo de bits seja entendido como números e seja possível fazer cálculos com os mesmos.</p>
<p>Um bom exemplo é a descrição de um contador, onde não se pode incrementar um sinal <code>std_logic_vector</code>. É preciso convertê-lo primeiro em <code>signed</code>, <code>unsiged</code> ou <code>integer</code>, fazer o incremento e se for o caso, convertê-lo novamente para <code>std_logic_vector</code>. Isso pode ser visto no trecho de código abaixo:</p>
<div class="sourceCode"><pre class="sourceCode vhdl"><code class="sourceCode vhdl">    <span class="kw">library</span> IEEE;
    <span class="kw">use</span> IEEE<span class="ot">.</span>std_logic_1164<span class="ot">.</span>all;
    <span class="kw">use</span> ieee<span class="ot">.</span>numeric_std<span class="ot">.</span>all

    signal val1<span class="ot">,</span> val2 <span class="ot">:</span> std_logic_vector( 31 downto 0 );

    <span class="co">-- Incorreto:</span>
    val2 <span class="ot">&lt;=</span> val1 <span class="ot">+</span> 1;

    <span class="co">-- Correto:</span>
    val2 <span class="ot">&lt;=</span> std_logic_vector( unsigned(val1) <span class="ot">+</span> 1 );</code></pre></div>
<p>Para fazer cálculos com tipos <code>signed</code> ou <code>unsigned</code> é necessário utilizar o pacote padronizado pelo IEEE: <code>numeric_std</code>. Por questões de compatibilidade, é preferível usar as bibliotecas e pacotes padronizados pelo IEEE.</p>
<p>A Synopsys possui bibliotecas que não são padronizadas, apesar da sua popularidade. <strong>O seu uso deve ser evitado</strong>. Elas são:</p>
<ul>
<li><p><strong><code>std_logic_signed</code></strong>;</p></li>
<li><p><strong><code>std_logic_unsigned</code></strong>;</p></li>
<li><p><strong><code>std_logic_arith</code></strong>.</p></li>
</ul>
<h4 id="atributos">Atributos</h4>
<p><strong>Atributos de sinais:</strong></p>
<ul>
<li><p>sinal‘delayed(<Tempo>) – Valor do sinal atrasado em <Tempo> unidades de tempo</p></li>
<li><p>sinal‘stable(<Tempo>) – True se nenhum evento ocorrer sobre o sinal nas últimas <Tempo> unidades de tempo.</p></li>
<li><p>sinal‘quiet(<Tempo>) – True se o sinal sinal se mantiver constante por <Tempo> unidades de tempo</p></li>
<li><p>sinal‘last_value – Valor do sinal sinal antes da última variação/mudança</p></li>
<li><p>sinal‘last_event – Instante no qual o sinal sinal sofreu alteração pela última vez</p></li>
<li><p>sinal‘last_active – Instante no qual o sinal esteve ativo na última vez</p></li>
<li><p>sinal‘event – True se um evento ocorreu no sinal sinal no ciclo corrente</p></li>
<li><p>sinal‘active – True se o sinal sinal está ativo no ciclo corrente</p></li>
<li><p>sinal‘transaction – Valor de bit alterado a cada vez que o sinal sinal sofre alterações</p></li>
</ul>
<p><strong>Atributos de escalares:</strong></p>
<ul>
<li><p>sinal’left – primeiro (mais a esquerda) valor em sinal</p></li>
<li><p>sinal’right – último (mais a direita) valor em sinal</p></li>
<li><p>sinal’low – menor valor em sinal</p></li>
<li><p>sinal’high – maior valor em sinal</p></li>
<li><p>sinal’ascending – True se sinal está em uma faixa ascendente, False caso contrário</p></li>
<li><p>sinal’image(x) – string representando o valor de x</p></li>
<li><p>sinal’value(s) – o valor em <Nome do Sinal> que é representado por s</p></li>
</ul>
<p><strong>Aplicados apenas a tipos discretos ou físicos:</strong></p>
<ul>
<li><p>sinal‘pos(x) – número da posição x em sinal;</p></li>
<li><p>sinal‘val(n) – valor contido na posição &quot;n&quot; do sinal.</p></li>
<li><p>sinal‘succ(x) – valor em sinal na posição um a mais que a de x</p></li>
<li><p>sinal‘pred(x) – valor em sinal na posição um a menos que a de x</p></li>
<li><p>sinal‘leftof(x) – valor em sinal na posição um a esquerda de x</p></li>
<li><p>sinal‘rightof(x) – valor em sinal na posição um a direita de x</p></li>
</ul>
<p><strong>Atributos de vetores:</strong></p>
<ul>
<li><p>sinal‘left(N) – Limite esquerdo da faixa de dimensão N do sinal sinal</p></li>
<li><p>sinal‘right(N) – Limite direito da faixa de dimensão N do sinal sinal</p></li>
<li><p>sinal‘low(N) – Limite inferior da faixa de dimensão N do sinal sinal</p></li>
<li><p>sinal‘high(N) – Limite superior da faixa de dimensão N do sinal sinal</p></li>
<li><p>sinal‘range(N) – Faixa do índice de dimensão N do sinal sinal</p></li>
<li><p>sinal‘reverse_range(N) – Reverso do índice de dimensão N do sinal sinal</p></li>
<li><p>sinal‘length(N) – Comprimento do índice de dimensão N do sinal sinal</p></li>
<li><p>sinal‘ascending(N) – True se faixa do indice de dimensão N de sinal está em uma faixa acendente, Falso caso contrário</p></li>
<li><p>sinal‘element(N) – Elemento subtipo de sinal</p></li>
</ul>
<hr />
<p><a name="paradigmaVHDL"></a></p>
<h2 id="paradigma-de-programação-vhdl">Paradigma de Programação VHDL</h2>
<p>A grande diferença entre o VHDL e as linguagens de programação:</p>
<ul>
<li><p>O VHDL <strong>descreve</strong> um circuito digital:</p>
<ul>
<li>Possuindo a descrição sequencial e a concorrente (onde as instruções são executadas todas ao mesmo tempo).</li>
</ul></li>
<li><p>As linguagens de programação possuem comandos que serão executados pelo processador:</p>
<ul>
<li>Em sequência, ou seja, uma instrução de cada vez.</li>
</ul></li>
</ul>
<p><a name="decConcorrentes"></a></p>
<h3 id="declarações-concorrentes">Declarações Concorrentes</h3>
<p>As declarações concorrentes descrevem os circuitos que trabalham em paralelo, ou seja, como nos circuitos combinacionais.</p>
<p>Nesses circuitos, uma mudança em qualquer das suas entradas poderá alterar a sua saída depois de um certo tempo de propagação. Um exemplo é o somador completo:</p>
<p><img src="../imagensCircuitos/FullAdder.svg" alt="Somador Completo" style="width:400px;"/></p>
<p>Uma possível descrição em VHDL está abaixo:</p>
<div class="sourceCode"><pre class="sourceCode vhdl"><code class="sourceCode vhdl"><span class="kw">library</span> IEEE;
<span class="kw">use</span> IEEE<span class="ot">.</span>std_logic_1164<span class="ot">.</span>all;

<span class="kw">entity</span> <span class="kw">fullAdder</span> <span class="kw">is</span>
    <span class="kw">port</span> ( A<span class="ot">,</span> B<span class="ot">,</span> Cin  <span class="ot">:</span> <span class="kw">in</span> <span class="dt">std_logic</span>;
             Soma<span class="ot">,</span> Cout <span class="ot">:</span> <span class="kw">out</span> <span class="dt">std_logic</span>
    );
<span class="er">end entity;</span>

<span class="kw">architecture</span> <span class="kw">fluxo</span> <span class="kw">of</span> <span class="kw">fullAdder</span> <span class="kw">is</span>
<span class="ot">signal</span> AB <span class="ot">:</span> <span class="dt">std_logic</span>;
    <span class="kw">begin</span>
    AB <span class="ot">&lt;=</span> A <span class="kw">XOR</span> B;
    Soma <span class="ot">&lt;=</span> AB <span class="kw">XOR</span> Cin;
    Cout <span class="ot">&lt;=</span> (A <span class="kw">AND</span> B) <span class="kw">OR</span> (AB <span class="kw">AND</span> Cin);
<span class="er">end architecture;</span></code></pre></div>
<p>Essa descrição é equivalente à que se segue:</p>
<div class="sourceCode"><pre class="sourceCode vhdl"><code class="sourceCode vhdl"><span class="kw">library</span> IEEE;
<span class="kw">use</span> IEEE<span class="ot">.</span>std_logic_1164<span class="ot">.</span>all;

<span class="kw">entity</span> <span class="kw">fullAdder</span> <span class="kw">is</span>
    <span class="kw">port</span> ( A<span class="ot">,</span> B<span class="ot">,</span> Cin  <span class="ot">:</span> <span class="kw">in</span> <span class="dt">std_logic</span>;
             Soma<span class="ot">,</span> Cout <span class="ot">:</span> <span class="kw">out</span> <span class="dt">std_logic</span>
    );
<span class="er">end entity;</span>

<span class="kw">architecture</span> <span class="kw">fluxo</span> <span class="kw">of</span> <span class="kw">fullAdder</span> <span class="kw">is</span>
<span class="ot">signal</span> AB <span class="ot">:</span> <span class="dt">std_logic</span>;
    <span class="kw">begin</span>
    Cout <span class="ot">&lt;=</span> (A <span class="kw">AND</span> B) <span class="kw">OR</span> (AB <span class="kw">AND</span> Cin);
    Soma <span class="ot">&lt;=</span> AB <span class="kw">XOR</span> Cin;
    AB <span class="ot">&lt;=</span> A <span class="kw">XOR</span> B;
<span class="er">end architecture;</span></code></pre></div>
<p>Ou seja, a ordem das atribuições não tem influencia no resultado já que todas são executadas concorrentemente.</p>
<p><a name="atribuicaoSinais"></a></p>
<h3 id="operador-de-atribuição-de-sinais-signal">Operador de Atribuição de Sinais (<code>signal</code>)</h3>
<p>Para distinguir das linguagens de programação, o VHDL utiliza um operador de atribuição com dois caracteres: &quot;&lt;=&quot;.</p>
<p>Seu nome é <em>signal assignment</em>. Ele indica uma relação entre sinais, mais especificamente, que o sinal à esquerda do operador depende dos sinais à direita deste.</p>
<p>Esse operador pode ser utilizado em quatro tipos diferentes de construções:</p>
<ul>
<li><p>Atribuição Concorrente de Sinais;</p></li>
<li><p>Atribuição Condicional de Sinais: <em>WHEN</em>;</p></li>
<li><p>Atribuição Seletiva de Sinais: <em>WITH SELECT</em>;</p></li>
<li><p>Declaração de Processo: <em>PROCESS</em>.</p></li>
</ul>
<p><a name="concorrenteAtribSinal"></a></p>
<h3 id="declarações-concorrentes-de-atribuição-de-sinais-signal">Declarações Concorrentes de Atribuição de Sinais (<code>signal</code>)</h3>
<p>Como visto <a href="#classesObjetos">anteriormente</a>, essa atribuição possui a seguinte sintaxe:</p>
<pre><code>&lt;target&gt; &lt;= &lt;expression&gt;;</code></pre>
<p><a name="condAtribSinalWhen"></a></p>
<h3 id="atribuição-condicional-de-sinais-when">Atribuição Condicional de Sinais (<code>when</code>)</h3>
<p>É utilizada quando existe somente um objeto que receberá a atribuição de uma expressão quando a condição especificada for verdadeira.</p>
<p>As <strong>condições são avaliadas sequencialmente até que encontre o primeiro resultado verdadeiro</strong>. Nesse caso, a expressão referente a essa condição será avaliada e atribuída ao objeto.</p>
<p>Essa construção possui somente uma atribuição que será e</p>
<p>A sua sintaxe está mostrada abaixo:</p>
<div class="sourceCode"><pre class="sourceCode vhdl"><code class="sourceCode vhdl"><span class="ot">&lt;</span>target<span class="ot">&gt;</span> <span class="ot">&lt;=</span> <span class="ot">&lt;</span>expression<span class="ot">&gt;</span> when <span class="ot">&lt;</span>condition<span class="ot">&gt;</span> else
            <span class="ot">&lt;</span>expression<span class="ot">&gt;</span> when <span class="ot">&lt;</span>condition<span class="ot">&gt;</span> else
            <span class="ot">&lt;</span>expression<span class="ot">&gt;</span>;</code></pre></div>
<p>O exemplo abaixo é um MUX de quatro entradas de um bit e uma saída.</p>
<div class="sourceCode"><pre class="sourceCode vhdl"><code class="sourceCode vhdl">
<span class="kw">library</span> IEEE;
<span class="kw">use</span> IEEE<span class="ot">.</span>std_logic_1164<span class="ot">.</span>all;

<span class="kw">entity</span> <span class="kw">my_4t1_mux</span> <span class="kw">is</span>
            <span class="kw">port</span>(D3<span class="ot">,</span> D2<span class="ot">,</span> D1<span class="ot">,</span> D0 <span class="ot">:</span> <span class="kw">in</span> <span class="dt">std_logic</span>;
                 SEL<span class="ot">:</span> <span class="kw">in</span> <span class="dt">std_logic_vector</span>(<span class="dv">1</span> <span class="ot">downto</span> <span class="dv">0</span>);
                 Y <span class="ot">:</span> <span class="kw">out</span> <span class="dt">std_logic</span>
            );
<span class="kw">end entity;</span>

<span class="kw">architecture</span> <span class="kw">mux4t1</span> <span class="kw">of</span> <span class="kw">my_4t1_mux</span> <span class="kw">is</span>
<span class="kw">begin</span>
    Y <span class="ot">&lt;=</span> D3 <span class="kw">when</span> (SEL <span class="ot">=</span> <span class="st">&quot;11&quot;</span>) else
         D2 <span class="kw">when</span> (SEL <span class="ot">=</span> <span class="st">&quot;10&quot;</span>) else
         D1 <span class="kw">when</span> (SEL <span class="ot">=</span> <span class="st">&quot;01&quot;</span>) else
         D0 <span class="kw">when</span> (SEL <span class="ot">=</span> <span class="st">&quot;00&quot;</span>) else
         <span class="bn">&#39;0&#39;</span>;
<span class="er">end architecture;</span></code></pre></div>
<p><img src="../imagensComponentes/MUX4-to-1.svg" alt="MUX 4 x 1" style="width:200px;"/></p>
<p>O último <em>else</em> aceita qualquer condição que não foi definida anteriormente, evitando a implementação de <em>latchs</em>.</p>
<p><a name="condAtribSinalWith"></a></p>
<h3 id="atribuição-seletiva-de-sinais-with-select">Atribuição Seletiva de Sinais (<code>with select</code>)</h3>
<p>Esta atribuição possui somente uma expressão de escolha a ser avaliada.</p>
<p>Nesta atribuição é considerado boa prática a inclusão de todos os casos esperados na expressão de escolha. E, ao final, adicionar a cláusula <em>when others</em>.</p>
<p>A sua sintaxe está mostrada abaixo:</p>
<div class="sourceCode"><pre class="sourceCode vhdl"><code class="sourceCode vhdl">with <span class="ot">&lt;</span>choose_expression<span class="ot">&gt;</span> select
        target <span class="ot">&lt;=</span> <span class="ot">&lt;</span>expression<span class="ot">&gt;</span> when <span class="ot">&lt;</span>choices<span class="ot">&gt;,</span>
                  <span class="ot">&lt;</span>expression<span class="ot">&gt;</span> when <span class="ot">&lt;</span>choices<span class="ot">&gt;</span>;</code></pre></div>
<p>Para efeito de comparação, o exemplo abaixo é um MUX de quatro entradas de um bit e uma saída.</p>
<div class="sourceCode"><pre class="sourceCode vhdl"><code class="sourceCode vhdl">
<span class="kw">library</span> IEEE;
<span class="kw">use</span> IEEE<span class="ot">.</span>std_logic_1164<span class="ot">.</span>all;

<span class="kw">entity</span> <span class="kw">my_4t1_mux</span> <span class="kw">is</span>
    <span class="kw">port</span> (D3<span class="ot">,</span> D2<span class="ot">,</span> D1<span class="ot">,</span> D0 <span class="ot">:</span> <span class="kw">in</span> <span class="dt">std_logic</span>;
          SEL <span class="ot">:</span> <span class="kw">in</span> <span class="dt">std_logic_vector</span>(<span class="dv">1</span> <span class="ot">downto</span> <span class="dv">0</span>);
          Y <span class="ot">:</span> <span class="kw">out</span> <span class="dt">std_logic</span>
    );
<span class="kw">end entity;</span>

<span class="kw">architecture</span> <span class="kw">mux4t1_2</span> <span class="kw">of</span> <span class="kw">my_4t1_mux</span> <span class="kw">is</span>
<span class="kw">begin</span>
    <span class="kw">with</span> SEL <span class="kw">select</span>
    Y <span class="ot">&lt;=</span> D3 <span class="kw">when</span> <span class="st">&quot;11&quot;</span><span class="ot">,</span>
         D2 <span class="kw">when</span> <span class="st">&quot;10&quot;</span><span class="ot">,</span>
         D1 <span class="kw">when</span> <span class="st">&quot;01&quot;</span><span class="ot">,</span>
         D0 <span class="kw">when</span> <span class="st">&quot;00&quot;</span><span class="ot">,</span>
         <span class="bn">&#39;0&#39;</span> <span class="kw">when</span> <span class="ot">others</span>;
<span class="er">end architecture;</span></code></pre></div>
<p>Está incluído em <em>&lt;choices&gt;</em> a opção <em>&quot;others&quot;</em>, que aceita qualquer condição que não foi definida anteriormente, evitando a implementação de <em>latchs</em>.</p>
<p><a name="processo"></a></p>
<h3 id="declaração-de-processos-process">Declaração de Processos (<code>process</code>)</h3>
<p>Sempre que for necessário um ambiente de execução sequencial, onde as linhas de código são executadas uma após a outra (como em C ou Java), é necessário utilizar a construção <code>process</code>.</p>
<p>Dentro de um processo, todas as instruções são executadas sequencialmente de cima para baixo. No entanto, o processo em si será executado simultaneamente com o resto do código.</p>
<p>No exemplo abaixo, a execução do <code>process</code> e a atribuição ao <code>port</code> G <strong>não são</strong> executadas sequencialmente. Eles são executados concorrentemente (tudo ao mesmo tempo).</p>
<div class="sourceCode"><pre class="sourceCode vhdl"><code class="sourceCode vhdl"><span class="kw">library</span> ieee;
<span class="kw">use</span> ieee<span class="ot">.</span>std_logic_1164<span class="ot">.</span>all;

<span class="kw">entity</span> <span class="kw">circuitoExemplo</span> <span class="kw">is</span>
    <span class="kw">port</span> (
        A<span class="ot">,</span>B<span class="ot">,</span>C <span class="ot">:</span> <span class="kw">in</span>   <span class="dt">std_logic</span>;
        F<span class="ot">,</span> G  <span class="ot">:</span> <span class="kw">out</span>  <span class="dt">std_logic</span>
    );
<span class="er">end entity;</span>

<span class="kw">architecture</span> <span class="kw">nome</span> <span class="kw">of</span> <span class="kw">circuitoExemplo</span> <span class="kw">is</span>

    <span class="ot">signal</span> sig_<span class="dv">1</span> <span class="ot">:</span> <span class="dt">std_logic</span>;

<span class="kw">begin</span>
    <span class="kw">process</span> (a<span class="ot">,</span>b<span class="ot">,</span>c) <span class="kw">is</span>    <span class="co">-- Este process é executado em paralelo com a atribuição ao G.</span>

    <span class="ot">variable</span> var_<span class="dv">1</span> <span class="ot">:</span> <span class="dt">integer</span>;

    <span class="kw">begin</span>                    <span class="co">-- Daqui até o &quot;end process&quot;, a execução é sequencial.</span>
          F <span class="ot">&lt;=</span> <span class="kw">not</span> (A <span class="kw">and</span> B <span class="kw">and</span> C);
          sig_<span class="dv">1</span> <span class="ot">&lt;=</span> A;
          var_<span class="dv">1</span> <span class="ot">:=</span> <span class="dv">34</span>;       <span class="co">-- esta atribuição é imediata.</span>
    <span class="er">end process</span>;             <span class="co">-- Fim do trecho sequencial.</span>

    G <span class="ot">&lt;=</span> <span class="kw">not</span> (A <span class="kw">and</span> B);  <span class="co">-- Esta atribuição é executada em paralelo com o process.</span>

<span class="kw">end architecture;</span></code></pre></div>
<!---
A declaração do processo é uma declaração simultânea. As declarações que aparecem dentro da declaração do processo são instruções sequenciais.

A instrução if tem uma analogia direta com a instrução de atribuição de sinal condicional usada no modelagem de fluxo de dados.

A declaração CASE tem uma analogia direta com a instrução de atribuição de sinal selecionada usada no modelagem de fluxo de dados.

Tanto a declaração do caso como a instrução if podem ser aninhadas. Declarações de atribuição de sinal concorrentes, condicionais e selecionadas não podem ser aninhadas.

A declaração concorrente mais simples é a declaração de atribuição de sinal concorrente (por exemplo, "F <= A;"). Seu equivalente sequencial é a declaração de atribuição de sinal seqüencial e possui a mesma sintaxe.
--->
<h3 id="laços">Laços:</h3>
<p style="color:red">
Falta Completar
</p>
<!--- PAREI AQUI --->
<h3 id="operadores-vhdl">Operadores VHDL:</h3>
<p style="color:red">
Falta Completar
</p>
<h4 id="operadores-lógicos">Operadores Lógicos</h4>
<p style="color:red">
Falta Completar
</p>
<h4 id="operadores-relacionais">Operadores Relacionais</h4>
<table>
<thead>
<tr class="header">
<th align="center">Operador</th>
<th></th>
<th align="left">Nome</th>
<th></th>
<th align="left">Teste Executado</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">=</td>
<td></td>
<td align="left">equivalência</td>
<td></td>
<td align="left">os valores são equivalentes?</td>
</tr>
<tr class="even">
<td align="center">/=</td>
<td></td>
<td align="left">não equivalência</td>
<td></td>
<td align="left">os valores não são equivalentes?</td>
</tr>
<tr class="odd">
<td align="center">&lt;</td>
<td></td>
<td align="left">menor que</td>
<td></td>
<td align="left">o valor da esquerda é menor?</td>
</tr>
<tr class="even">
<td align="center">&lt;=</td>
<td></td>
<td align="left">menor que ou igual</td>
<td></td>
<td align="left">o valor da esquerda é menor ou igual?</td>
</tr>
<tr class="odd">
<td align="center">&gt;</td>
<td></td>
<td align="left">maior que</td>
<td></td>
<td align="left">o valor da esquerda é maior?</td>
</tr>
<tr class="even">
<td align="center">&gt;=</td>
<td></td>
<td align="left">maior que ou igual</td>
<td></td>
<td align="left">o valor da esquerda é maior ou igual?</td>
</tr>
</tbody>
</table>
<h4 id="operadores-de-deslocamento">Operadores de Deslocamento</h4>
<p style="color:red">
Falta Completar com Desenhos
</p>
<table style="width:58%;">
<colgroup>
<col width="4%" />
<col width="5%" />
<col width="23%" />
<col width="18%" />
<col width="6%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Operador</th>
<th align="center">Nome</th>
<th align="left">Função</th>
<th align="left">Exemplo</th>
<th align="left">Resultado</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Lógico</td>
<td align="center">sll</td>
<td align="left">deslocamento lógico para a esquerda</td>
<td align="left">resultado &lt;= ”10010101” sll 2</td>
<td align="left">”01010100”</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="center">srl</td>
<td align="left">deslocamento lógico para a direita</td>
<td align="left">resultado &lt;= ”10010101” srl 3</td>
<td align="left">”00010010”</td>
</tr>
<tr class="odd">
<td align="left">Aritmético</td>
<td align="center">sla</td>
<td align="left">deslocamento aritmético para a esquerda</td>
<td align="left">resultado &lt;= ”10010101” sla 3</td>
<td align="left">”10101111”</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="center">sra</td>
<td align="left">deslocamento aritmético para a direita</td>
<td align="left">resultado &lt;= ”10010101” sra 2</td>
<td align="left">”11100101”</td>
</tr>
<tr class="odd">
<td align="left">Rotação</td>
<td align="center">rol</td>
<td align="left">rotação para a esquerda</td>
<td align="left">resultado &lt;= ”101000” rol 2</td>
<td align="left">”100010”</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="center">ror</td>
<td align="left">rotação para a direita</td>
<td align="left">resultado &lt;= ”101001” ror 2</td>
<td align="left">”011010”</td>
</tr>
</tbody>
</table>
<h4 id="operador-outros-others">Operador Outros (<code>others</code>)</h4>
<p style="color:red">
Falta Completar
</p>
<h4 id="operadores-de-concatenação">Operadores de Concatenação</h4>
<div class="sourceCode"><pre class="sourceCode vhdl"><code class="sourceCode vhdl">
signal A_val<span class="ot">,</span> B_val <span class="ot">:</span> std_logic_vector(3 downto 0);
signal C_val <span class="ot">:</span> std_logic_vector(5 downto 0);
signal D_val <span class="ot">:</span> std_logic_vector(7 downto 0);
<span class="co">------</span>
C_val <span class="ot">&lt;=</span> A_val <span class="ot">&amp;</span> <span class="st">&quot;00&quot;</span>;
C_val <span class="ot">&lt;=</span> <span class="st">&quot;11&quot;</span> <span class="ot">&amp;</span> B_val;
C_val <span class="ot">&lt;=</span> <span class="bn">&#39;1&#39;</span> <span class="ot">&amp;</span> A_val <span class="ot">&amp;</span> <span class="bn">&#39;0&#39;</span>;
D_val <span class="ot">&lt;=</span> <span class="st">&quot;0001&quot;</span> <span class="ot">&amp;</span> C_val(3 downto 0);
D_val <span class="ot">&lt;=</span> A_val <span class="ot">&amp;</span> B_val;</code></pre></div>
<h4 id="operadores-módulo-e-resto">Operadores Módulo e Resto</h4>
<table>
<thead>
<tr class="header">
<th align="left">Operador</th>
<th align="center"></th>
<th></th>
<th align="left">Nome</th>
<th></th>
<th align="left">Comentário</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Adição</td>
<td align="center">+</td>
<td></td>
<td align="left">adição</td>
<td></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="center">-</td>
<td></td>
<td align="left">subtração</td>
<td></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">Unário</td>
<td align="center">+</td>
<td></td>
<td align="left">identidade</td>
<td></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="center">-</td>
<td></td>
<td align="left">negação</td>
<td></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="center">*</td>
<td></td>
<td align="left">multiplicação</td>
<td></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">Multiplicação</td>
<td align="center">/</td>
<td></td>
<td align="left">divisão</td>
<td></td>
<td align="left">comumente limitado a potência de 2</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="center">mod</td>
<td></td>
<td align="left">módulo</td>
<td></td>
<td align="left">somente para tipos específicos</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="center">rem</td>
<td></td>
<td align="left">resto</td>
<td></td>
<td align="left">somente para tipos específicos</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="center">**</td>
<td></td>
<td align="left">exponenciação</td>
<td></td>
<td align="left">comumente limitado a potência de 2</td>
</tr>
<tr class="even">
<td align="left">Outros</td>
<td align="center">abs</td>
<td></td>
<td align="left">valor absoluto</td>
<td></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="center">&amp;</td>
<td></td>
<td align="left">concatenação</td>
<td></td>
<td align="left">somente para tipos específicos</td>
</tr>
</tbody>
</table>
<h4 id="circuitos-sequenciais">Circuitos Sequenciais</h4>
<p style="color:red">
Falta Completar
</p>
<h4 id="elementos-de-armazenamento">Elementos de Armazenamento</h4>
<p>Elementos de armazenamento em VHDL são inferidos pela ausência da especificação do valor de saída para qualquer, possível, condição de entrada.</p>
<p>A geração não intencional de elementos de armazenamento geralmente é listada pelo sintetizador como geração de <code>latch</code>. Mais uma vez, os <code>latchs</code> são geradas quando há pelo menos uma condição de entrada que não possui uma especificação de saída correspondente.</p>
<p>Os elementos de memória podem ser induzidos tanto:</p>
<ul>
<li><p>No estilo de modelagem por fluxo de dados;</p></li>
<li><p>Quanto no estilo de modelagem comportamental.</p></li>
</ul>
<p>Se um sinal for declarado na entidade como sendo de saída (<code>out</code>), ele não poderá aparecer no lado direito de um operador de atribuição de <code>signal</code>. Esta limitação pode ser contornada usando-se <code>signals</code> intermediários para quaisquer atribuições funcionais. Em seguida, atribui-se o <code>signal</code> intermediário ao <code>signal</code> de saída (uma atribuição concorrente).</p>
<p>A especificação de modo de <code>buffer</code> deve ser evitada. Em seu lugar pode-se utilizar a declaração de <code>signals</code> intermediários.</p>
<h3 id="generate-if">Generate if</h3>
<p style="color:red">
Falta Completar
</p>
<hr />
<h2 id="estilos-usados-nas-arquiteturas">Estilos usados nas Arquiteturas:</h2>
<h3 id="comportamental">Comportamental:</h3>
<p>O estilo comportamental não fornece detalhes sobre como o projeto é implementado no hardware. Ele define como as saídas do circuito reagem às entradas e suas variações. Assim, os detalhes da implementação do circuito são deixados aos cuidados da ferramenta de síntese.</p>
<p>A modelagem comportamental está em um nível de abstração acima da modelagem de fluxo de dados. Pode-se dizer que a modelagem comportamental, no projeto de circuitos, é a própria abordagem &quot;caixa-preta&quot;.</p>
<p>A modelagem comportamental se baseia na declaração do processo (<code>process</code>), que é um tipo de declaração simultânea que executa o seu conteúdo de forma sequencial.</p>
<p>A principal diferença entre <code>process</code> e as outras três declarações concorrentes está na abordagem da concorrência que o processo usa.</p>
<h5 id="comando-process">Comando Process:</h5>
<p style="color:red">
Falta Completar
</p>
<hr />
<h3 id="fluxo-de-dados">Fluxo de Dados:</h3>
<p>Esse estilo de arquitetura especifica um circuito como uma representação simultânea do fluxo de dados através do circuito.</p>
<p>Na abordagem de fluxo de dados, os circuitos são descritos mostrando as relações de entrada e saída entre os vários componentes internos do VHDL. Esses componentes incluem operadores como AND, OR, XOR, etc.</p>
<p>Os modelos em estilo de fluxo de dados, por definição, usam as seguintes atribuições:</p>
<ul>
<li><p>Atribuição concorrente de sinal;</p></li>
<li><p>Atribuição condicional de sinal;</p></li>
<li><p>Atribuição seletiva de sinal.</p></li>
</ul>
<!--
blocking assignments inside process are evaluated in the order in which they appear in the code, just as one would expect in a standard programming language.

nonblocking assignments inside process are evaluated concurrently; all of the statements are evaluated before any of the signals on the left hand sides are updated.
-->
<p>Se o seu modelo usou exclusivamente essas três instruções de atribuição de sinal, ele é um modelo de fluxo de dados.</p>
<p>O estilo de arquitetura descrita através de fluxo de dados tem pontos fortes e pontos fracos:</p>
<ul>
<li><p>É possível ver o fluxo de dados no circuito examinando o código VHDL.</p></li>
<li><p>Estimar como a lógica real será após a síntese do circuito.</p></li>
<li><p>Funciona bem para circuitos pequenos e relativamente simples.</p></li>
<li><p>Para circuitos mais complicados é vantajoso usar o estilo comportamental.</p></li>
</ul>
<p>O exemplo abaixo é uma modelagem no estilo fluxo de dados.</p>
<div class="sourceCode"><pre class="sourceCode vhdl"><code class="sourceCode vhdl"><span class="kw">entity</span> <span class="kw">AND2</span> <span class="kw">is</span>
      <span class="kw">port</span> (
          X<span class="ot">,</span> Y <span class="ot">:</span> <span class="kw">in</span>   <span class="dt">BIT</span>;
          Z    <span class="ot">:</span> <span class="kw">out</span>  <span class="dt">BIT</span>
      );
<span class="er">end entity;</span>

<span class="kw">architecture</span> <span class="kw">FluxoDados</span> <span class="kw">of</span> <span class="kw">AND2</span> <span class="kw">is</span>
<span class="kw">begin</span>
      Z <span class="ot">&lt;=</span> X <span class="kw">AND</span> Y;
<span class="er">end architecture;</span></code></pre></div>
<h3 id="estrutural">Estrutural:</h3>
<p>Em VHDL, a modularidade é conseguida através do uso de pacotes (<code>packages</code>), componentes (<code>components</code>) e funções (<code>functions</code>). A seguir, veremos como usar os componentes.</p>
<p>A abordagem para usar um componente no VHDL é:</p>
<ol style="list-style-type: decimal">
<li><p>Nomeie o módulo que você planeja descrever (a entidade);</p></li>
<li><p>Descreva o que o módulo fará (a arquitetura);</p></li>
<li><p>Deixe o programa saber que o módulo existe e pode ser usado (declaração do componente);</p></li>
<li><p>Use o módulo em seu código, fazendo a instanciação do componente e o mapeamento.</p></li>
</ol>
<div class="figure">
<img src="../imagensVHDL/projetoHierarquico-1A.svg#p20" alt="Modelagem Estrutural" />
<p class="caption"><strong>Modelagem Estrutural</strong></p>
</div>
<p><a name="instanciar"></a></p>
<h4 id="instanciação-de-componentes">Instanciação de Componentes</h4>
<p><strong>Instanciação Direta</strong></p>
<p>Quando for instanciar um componente, do seu próprio projeto, é possível usar a instanciação direta - sem a declaração do componente.</p>
<div class="sourceCode"><pre class="sourceCode vhdl"><code class="sourceCode vhdl"><span class="ot">&lt;</span>instance_name<span class="ot">&gt;:</span> <span class="kw">entity</span> <span class="ot">&lt;</span><span class="kw">library</span><span class="ot">&gt;.&lt;</span>entity_name<span class="ot">&gt;</span>
    <span class="kw">generic</span> <span class="kw">map</span>
    (
        <span class="ot">&lt;</span>name<span class="ot">&gt;</span> <span class="ot">=&gt;</span> <span class="ot">&lt;</span>value<span class="ot">&gt;,</span>
        <span class="ot">...</span>
    )
    <span class="kw">port</span> <span class="kw">map</span>
    (
        <span class="ot">&lt;</span>formal_input<span class="ot">&gt;</span> <span class="ot">=&gt;</span> <span class="ot">&lt;</span>expression<span class="ot">&gt;,</span>
        <span class="ot">&lt;</span>formal_output<span class="ot">&gt;</span> <span class="ot">=&gt;</span> <span class="ot">&lt;signal&gt;,</span>
        <span class="ot">&lt;</span>formal_inout<span class="ot">&gt;</span> <span class="ot">=&gt;</span> <span class="ot">&lt;signal&gt;,</span>
        <span class="ot">...</span>
    );</code></pre></div>
<p>A biblioteca do projeto sempre tem o nome <em>work</em>.</p>
<p>O <em>port map</em> pode ser feito de duas formas:</p>
<ul>
<li><p>Posicional:</p>
<ul>
<li>Na mesma ordem original dos <em>ports</em> do componente, é declarado o sinal que será conectado.</li>
</ul></li>
<li><p>Nominal:</p>
<ul>
<li><p>Para evitar os erros comuns na conexão do <em>port map</em>, utiliza-se uma sintaxe que não depende da ordem original dos <em>ports</em>.</p></li>
<li><p>Em qualquer ordem, os ports são conectados com uma atribuição usando o nome de cada um deles, como mostrado a seguir.</p></li>
</ul></li>
</ul>
<div class="sourceCode"><pre class="sourceCode vhdl"><code class="sourceCode vhdl">            <span class="ot">&lt;</span>formal_input<span class="ot">&gt;</span> <span class="ot">=&gt;</span> <span class="ot">&lt;</span>expression<span class="ot">&gt;</span>
            <span class="ot">&lt;</span>formal_output<span class="ot">&gt;</span> <span class="ot">=&gt;</span> <span class="ot">&lt;</span>signal<span class="ot">&gt;</span></code></pre></div>
<p>A etiqueta <em>formal_input</em> ou <em>formal_output</em> será substituída pelo nome original do <em>port</em> do componente que está sendo instanciado. Ela deve ser seguida pelo símbolo de atribuição (=&gt;).</p>
<p>Do lado direito do símbolo de atribuição, colocamos o nome da expressão, ou sinal, pertencente a um recurso existente no arquivo local que será conectado ao <em>port</em> do componente instanciado. Como são definidos os nomes dos dois recursos utilizados, o local e o instanciado, a sequência das declarações não importa.</p>
<p><br></p>
<p><strong>Instanciação Usando <em>component</em></strong></p>
<p>Ao invés de fazer a instanciação direta, definimos primeiro o componente que será utilizado e suas características. O que é basicamente a definição da entidade do componente que iremos utilizar, como pode ser visto abaixo:</p>
<table>
<thead>
<tr class="header">
<th>Entidade</th>
<th></th>
<th>Componente</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>entity INVERSOR is</code></td>
<td></td>
<td><code>component INVERSOR</code></td>
</tr>
<tr class="even">
<td><code>port (</code></td>
<td></td>
<td><code>port (</code></td>
</tr>
<tr class="odd">
<td><code>A: in STD_LOGIC;</code></td>
<td></td>
<td><code>A: in STD_LOGIC;</code></td>
</tr>
<tr class="even">
<td><code>S: out STD_LOGIC);</code></td>
<td></td>
<td><code>S: out STD_LOGIC);</code></td>
</tr>
<tr class="odd">
<td><code>end INVERSOR;</code></td>
<td></td>
<td><code>end component;</code></td>
</tr>
</tbody>
</table>
<p>Modelo do código VHDDL:</p>
<div class="sourceCode"><pre class="sourceCode vhdl"><code class="sourceCode vhdl">
component <span class="ot">&lt;</span>component_name<span class="ot">&gt;</span>

    generic
    (
        <span class="ot">&lt;</span>name<span class="ot">&gt;</span> <span class="ot">:</span> <span class="ot">&lt;</span>type<span class="ot">&gt;</span>;
        <span class="ot">&lt;</span>name<span class="ot">&gt;</span> <span class="ot">:</span> <span class="ot">&lt;</span>type<span class="ot">&gt;</span> <span class="ot">:=</span> <span class="ot">&lt;</span>default_value<span class="ot">&gt;</span>
    );

    port
    (
        <span class="co">-- Input ports</span>
        <span class="ot">&lt;</span>name<span class="ot">&gt;</span>  <span class="ot">:</span> in  <span class="ot">&lt;</span>type<span class="ot">&gt;</span>;
        <span class="ot">&lt;</span>name<span class="ot">&gt;</span>  <span class="ot">:</span> in  <span class="ot">&lt;</span>type<span class="ot">&gt;</span> <span class="ot">:=</span> <span class="ot">&lt;</span>default_value<span class="ot">&gt;</span>;

        <span class="co">-- Inout ports</span>
        <span class="ot">&lt;</span>name<span class="ot">&gt;</span>  <span class="ot">:</span> inout <span class="ot">&lt;</span>type<span class="ot">&gt;</span>;

        <span class="co">-- Output ports</span>
        <span class="ot">&lt;</span>name<span class="ot">&gt;</span>  <span class="ot">:</span> out <span class="ot">&lt;</span>type<span class="ot">&gt;</span>;
        <span class="ot">&lt;</span>name<span class="ot">&gt;</span>  <span class="ot">:</span> out <span class="ot">&lt;</span>type<span class="ot">&gt;</span> <span class="ot">:=</span> <span class="ot">&lt;</span>default_value<span class="ot">&gt;</span>
    );

end component;</code></pre></div>
<p>Essa definição é colocada dentro da arquitetura, entre o <em>architecture</em> e o <em>begin</em>, do módulo em que ela será utilizado.</p>
<p>A instanciação é feita dentro da arquitetura, entre o <em>begin</em> e o <em>end</em> e segue o padrão da instanciação direta.</p>
<p>Abaixo pode-se ver um exemplo de descrição estrutural. É a constução de uma porta NAND através da conexão de uma porta AND e outra NOT (definidas em outros arquivos do projeto).</p>
<div class="sourceCode"><pre class="sourceCode vhdl"><code class="sourceCode vhdl">
<span class="kw">entity</span> <span class="kw">NAND2</span> <span class="kw">is</span>
   <span class="kw">port</span> (
        A<span class="ot">,</span>B <span class="ot">:</span> <span class="kw">in</span> <span class="dt">BIT</span>;
        Z   <span class="ot">:</span> <span class="kw">out</span> <span class="dt">BIT</span>
    );
<span class="er">end entity;</span>

<span class="kw">architecture</span> <span class="kw">STRUCTURAL</span> <span class="kw">of</span> <span class="kw">NAND2</span> <span class="kw">is</span>

    <span class="co">-- Utilizado com um fio entre a saída da porta AND e a entrada do INVERSOR.</span>
    <span class="ot">signal</span> I<span class="ot">:</span> <span class="dt">Bit</span>;

    <span class="co">-- A entidade do componente está definida em outro arquivo do projeto.</span>
    <span class="co">-- Aqui é declarada a sua utilização.</span>

    <span class="kw">component</span> <span class="kw">AND_2</span> <span class="kw">is</span>
        <span class="kw">port</span>(
            I1<span class="ot">,</span>I2<span class="ot">:</span> <span class="kw">in</span> <span class="dt">Bit</span>;
            O1<span class="ot">:</span> <span class="kw">out</span> <span class="dt">BIT</span>
        );
    <span class="er">end component;</span>

    <span class="kw">component</span> <span class="kw">INVERT</span> <span class="kw">is</span>
        <span class="kw">port</span>(
            I1<span class="ot">:</span> <span class="kw">in</span> <span class="dt">Bit</span>;
            O1<span class="ot">:</span> <span class="kw">out</span> <span class="dt">Bit</span>
        );
    <span class="er">end component;</span>

<span class="kw">begin</span>
    <span class="co">-- Instancia os componentes e faz as conexões (mapeamento):</span>
    <span class="kw">U0</span><span class="ot">:</span> <span class="er">AND_</span><span class="dv">2</span> <span class="kw">port map (</span>I1<span class="ot">,</span>I2<span class="ot">,</span>I);         <span class="co">--faz a conexão através do posicionamento.</span>
    <span class="kw">U1</span><span class="ot">:</span> <span class="er">INVERT</span> <span class="kw">port map (</span>I1<span class="ot">=&gt;</span>I<span class="ot">,</span> O1<span class="ot">=&gt;</span>Z);   <span class="co">--faz a conexão de forma explicita (nominal).</span>
<span class="kw">end architecture;</span></code></pre></div>
<!---

Modelagem estrutural em VHDL suporta conceitos de design hierárquico. A capacidade de abstrair circuitos digitais para níveis mais altos é a chave para entender e projetar circuitos digitais complexos.

O design digital usando captura esquemática é uma abordagem desatualizada: você deve resistir à inclinação e / ou diretiva a todo custo.

O modelo estrutural VHDL suporta a reutilização de unidades de design. Isso inclui as unidades que você já criou, bem como a capacidade de usar bibliotecas de módulos predefinidos.

Se você usa uma ferramenta de desenvolvimento de software FPGA de um dos principais players de FPGA no mercado, você poderá usar blocos digitais já desenvolvidos uma vez que os declarar. Nesse caso, a declaração da entidade não é a da Lista 8.2, mas sim uma inclusão de biblioteca simples em seu código VHDL que se parece:

Structural modeling in VHDL supports hierarchical design concepts. The ability to abstract digital circuits to higher levels is the key to understanding and designing complex digital circuits.

Digital design using schematic capture is an outdated approach: you should resist the inclination and/or directive at all costs.

The VHDL structural model supports the reuse of design units. This includes units you have previously designed as well as the ability to use predefined module libraries.

If you use one FPGA software development tool from one of the major FPGA players in the market, you will be able to use digital blocks already developed once you declare them. In this case the entity declaration is not the one of Listing 8.2 but instead a simple library inclusionin your VHDL code that looks like:

```vhdl

library UNISIM;
use UNISIM.VComponents.all;
```

All digital blocks available from this library package are described in the documentation of the FPGA software development tool (e.g. Xilinx ISE).
--->
<!---

***

### Máquinas de Estados Finitos ###  -->
<!---  Important Points
Modeling FSMs from a state diagram is a straightforward process using VHDL behavioral modeling. The process is so straightforward that it is often considered cookie cutter. The real engineering involved in implementing FSM is in the generation of the state diagram that solved the problem at hand.

Due to the general versatility of VHDL, there are many approaches that can be used to model FSMs using VHDL. The approach used here details only one of those styles but is generally considered the most straightforward of all styles.

The actual encoding of the FSM’s state variables when enumeration types are used is left up to the synthesis tool. If a preferred method of variable encoding is desired, using the attribute approach detail in this section is a simple but viable alternative.

***
--->
<!---  ### RTL  -->
<!--- Important Points:
VHDL can be used to easily implement circuits at the register transfer level. The corresponding VHDL models can be implemented in either structural of full behavioral format

RTL level VHDL models should strive for simplicity in their designs.
If the behavioral models in the RTL design become complicated, the chances that your circuit works correctly greatly diminish due to the synthesis of the complicated circuit.
--->
<p><br><br></p>
<hr />
<p><a name="tabelaPalavrasReservadas"></a></p>
<h2 id="palavras-reservadas">Palavras Reservadas:</h2>
<p>São identificadores reservados da linguagem VHDL. Possuem propósito especial e não devem ser utilizadas para declarar identificadores no código sendo escrito.</p>
<table style="width:72%;">
<colgroup>
<col width="8%" />
<col width="63%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Palavra</th>
<th align="left">Utilização</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><strong>abs</strong></td>
<td align="left">Operador. Valor absoluto do operando à direita. Não usa: ()</td>
</tr>
<tr class="even">
<td align="left"><strong>access</strong></td>
<td align="left">Usado para definir um tipo de acesso, um ponteiro</td>
</tr>
<tr class="odd">
<td align="left"><strong>after</strong></td>
<td align="left">Especifica um atraso</td>
</tr>
<tr class="even">
<td align="left"><strong>alias</strong></td>
<td align="left">Criar outro nome para um identificador existente</td>
</tr>
<tr class="odd">
<td align="left"><strong>all</strong></td>
<td align="left">Desreferencia o que precede o .all</td>
</tr>
<tr class="even">
<td align="left"><strong>and</strong></td>
<td align="left">Operador lógico &quot;e&quot;. Operandos ficam à esquerda e direita</td>
</tr>
<tr class="odd">
<td align="left"><strong>architecture</strong></td>
<td align="left">Unidade de projeto</td>
</tr>
<tr class="even">
<td align="left"><strong>array</strong></td>
<td align="left">Usado para definir um array, vetor ou matriz</td>
</tr>
<tr class="odd">
<td align="left"><strong>assert</strong></td>
<td align="left">Verificação do programa feita por ele mesmo</td>
</tr>
<tr class="even">
<td align="left"><strong>attribute</strong></td>
<td align="left">Usado para declarar atributos de funções</td>
</tr>
<tr class="odd">
<td align="left"><strong>begin</strong></td>
<td align="left">Início de um trecho definido por begin/end</td>
</tr>
<tr class="even">
<td align="left"><strong>block</strong></td>
<td align="left">Início de uma estrutura de bloco</td>
</tr>
<tr class="odd">
<td align="left"><strong>body</strong></td>
<td align="left">Utilizado na declaração de pacote: &quot;package body&quot;</td>
</tr>
<tr class="even">
<td align="left"><strong>buffer</strong></td>
<td align="left">Um modo de um sinal</td>
</tr>
<tr class="odd">
<td align="left"><strong>bus</strong></td>
<td align="left">Um modo de um sinal, pode ter vários sinais internos</td>
</tr>
<tr class="even">
<td align="left"><strong>case</strong></td>
<td align="left">Parte do comando case</td>
</tr>
<tr class="odd">
<td align="left"><strong>component</strong></td>
<td align="left">Inicia a definição de um componente</td>
</tr>
<tr class="even">
<td align="left"><strong>configuration</strong></td>
<td align="left">Uma unidade de projeto primária</td>
</tr>
<tr class="odd">
<td align="left"><strong>constant</strong></td>
<td align="left">Declara que um identificador é somente de leitura</td>
</tr>
<tr class="even">
<td align="left"><strong>disconnect</strong></td>
<td align="left">Condição de um sinal</td>
</tr>
<tr class="odd">
<td align="left"><strong>downto</strong></td>
<td align="left">Indica um intervalo decrescente: 31 downto 0</td>
</tr>
<tr class="even">
<td align="left"><strong>else</strong></td>
<td align="left">Parte do comando &quot;if&quot;</td>
</tr>
<tr class="odd">
<td align="left"><strong>elsif</strong></td>
<td align="left">Parte do comando &quot;if&quot;</td>
</tr>
<tr class="even">
<td align="left"><strong>end</strong></td>
<td align="left">Parte de muitos comandos, pode ser seguido por palavra reservada ou identificador</td>
</tr>
<tr class="odd">
<td align="left"><strong>entity</strong></td>
<td align="left">Uma unidade de projeto primária</td>
</tr>
<tr class="even">
<td align="left"><strong>exit</strong></td>
<td align="left">Instrução sequencial, usada em laços</td>
</tr>
<tr class="odd">
<td align="left"><strong>file</strong></td>
<td align="left">Usado para declarar um arquivo</td>
</tr>
<tr class="even">
<td align="left"><strong>for</strong></td>
<td align="left">Início de um comando de laço</td>
</tr>
<tr class="odd">
<td align="left"><strong>function</strong></td>
<td align="left">Inicia declaração e corpo de uma função</td>
</tr>
<tr class="even">
<td align="left"><strong>generate</strong></td>
<td align="left">Fazer cópias, possivelmente usando um parâmetro</td>
</tr>
<tr class="odd">
<td align="left"><strong>generic</strong></td>
<td align="left">Introduz uma parte genérica de uma declaração</td>
</tr>
<tr class="even">
<td align="left"><strong>group</strong></td>
<td align="left">Coleção de tipos que podem receber um atributo</td>
</tr>
<tr class="odd">
<td align="left"><strong>guarded</strong></td>
<td align="left">Causa uma espera até que um sinal mude de Falso para Verdadeiro</td>
</tr>
<tr class="even">
<td align="left"><strong>if</strong></td>
<td align="left">Usado no comando &quot;if&quot;</td>
</tr>
<tr class="odd">
<td align="left"><strong>impure</strong></td>
<td align="left">Uma função impura é suposta como tendo efeitos colaterais</td>
</tr>
<tr class="even">
<td align="left"><strong>in</strong></td>
<td align="left">Indica um parâmetro de entrada</td>
</tr>
<tr class="odd">
<td align="left"><strong>inertial</strong></td>
<td align="left">Característica de um sinal</td>
</tr>
<tr class="even">
<td align="left"><strong>inout</strong></td>
<td align="left">Indica que um parâmetro é de entrada e saída</td>
</tr>
<tr class="odd">
<td align="left"><strong>is</strong></td>
<td align="left">Usado como um conectivo em várias declarações</td>
</tr>
<tr class="even">
<td align="left"><strong>label</strong></td>
<td align="left">Nome de atributo usado como especificação de entidade</td>
</tr>
<tr class="odd">
<td align="left"><strong>library</strong></td>
<td align="left">Designa um nome de biblioteca</td>
</tr>
<tr class="even">
<td align="left"><strong>linkage</strong></td>
<td align="left">Um modo para uma porta, usado como buffer e inout</td>
</tr>
<tr class="odd">
<td align="left"><strong>literal</strong></td>
<td align="left">Usado na declaração de atributo de grupos</td>
</tr>
<tr class="even">
<td align="left"><strong>loop</strong></td>
<td align="left">Instrução sequencial: loop ... end loop;</td>
</tr>
<tr class="odd">
<td align="left"><strong>map</strong></td>
<td align="left">Usado para mapear parâmetros, como no <em>port map</em></td>
</tr>
<tr class="even">
<td align="left"><strong>mod</strong></td>
<td align="left">Operador. Módulo do operando à esquerda pelo operando da direita</td>
</tr>
<tr class="odd">
<td align="left"><strong>nand</strong></td>
<td align="left">Operador. &quot;NAND&quot; entre operandos da esquerda e direita</td>
</tr>
<tr class="even">
<td align="left"><strong>new</strong></td>
<td align="left">Aloca memória e retorna ponteiro de acesso</td>
</tr>
<tr class="odd">
<td align="left"><strong>next</strong></td>
<td align="left">Instrução sequencial, usada em laços (loop)</td>
</tr>
<tr class="even">
<td align="left"><strong>nor</strong></td>
<td align="left">Operador. &quot;NOR&quot; de operandos à esquerda e direita</td>
</tr>
<tr class="odd">
<td align="left"><strong>not</strong></td>
<td align="left">Operador. complemento de operando à direita</td>
</tr>
<tr class="even">
<td align="left"><strong>null</strong></td>
<td align="left">Pode ser uma instrução sequencial que não faz nada ou um valor</td>
</tr>
<tr class="odd">
<td align="left"><strong>of</strong></td>
<td align="left">Usado em declarações de tipo: nome &quot;of&quot; TIPO;</td>
</tr>
<tr class="even">
<td align="left"><strong>on</strong></td>
<td align="left">Usado como um conectivo em várias declarações</td>
</tr>
<tr class="odd">
<td align="left"><strong>open</strong></td>
<td align="left">Trabalhar com arquivo</td>
</tr>
<tr class="even">
<td align="left"><strong>or</strong></td>
<td align="left">Operador. &quot;OU&quot; lógico entre operandos da esquerda e direita</td>
</tr>
<tr class="odd">
<td align="left"><strong>others</strong></td>
<td align="left">Preencher os dados faltantes, pode até ser todos</td>
</tr>
<tr class="even">
<td align="left"><strong>out</strong></td>
<td align="left">Indica que um que é uma saída</td>
</tr>
<tr class="odd">
<td align="left"><strong>package</strong></td>
<td align="left">Uma unidade de projeto contendo subprogramas, funções, componentes, etc... Também pode ser: package body</td>
</tr>
<tr class="even">
<td align="left"><strong>port</strong></td>
<td align="left">Definição de interface. Também pode ser: port map</td>
</tr>
<tr class="odd">
<td align="left"><strong>postponed</strong></td>
<td align="left">Faz o &quot;process&quot; esperar por todos os processos não adiados</td>
</tr>
<tr class="even">
<td align="left"><strong>procedure</strong></td>
<td align="left">Um procedimento de programação</td>
</tr>
<tr class="odd">
<td align="left"><strong>process</strong></td>
<td align="left">Define o código sequencial ou concorrente a ser executado</td>
</tr>
<tr class="even">
<td align="left"><strong>pure</strong></td>
<td align="left">Uma função pura pode não ter efeitos secundários</td>
</tr>
<tr class="odd">
<td align="left"><strong>range</strong></td>
<td align="left">Utilizado nas definições de tipo: range 1 to 10;</td>
</tr>
<tr class="even">
<td align="left"><strong>record</strong></td>
<td align="left">Define um novo tipo de registro</td>
</tr>
<tr class="odd">
<td align="left"><strong>register</strong></td>
<td align="left">Modificador de parâmetro do sinal</td>
</tr>
<tr class="even">
<td align="left"><strong>reject</strong></td>
<td align="left">Cláusula no mecanismo de atraso (delay). Deve ser seguido por um valor de tempo</td>
</tr>
<tr class="odd">
<td align="left"><strong>rem</strong></td>
<td align="left">Operador. Resto da divisão do operando da esquerda pelo da direita</td>
</tr>
<tr class="even">
<td align="left"><strong>report</strong></td>
<td align="left">Instrução e cláusula utilizada na instrução &quot;assert&quot;. Envia uma &quot;string&quot; para a saída</td>
</tr>
<tr class="odd">
<td align="left"><strong>return</strong></td>
<td align="left">Declaração usada em procedimento ou função</td>
</tr>
<tr class="even">
<td align="left"><strong>rol</strong></td>
<td align="left">Operando da esquerda é rotacionado à esquerda o total de vezes indicado no operando da direita</td>
</tr>
<tr class="odd">
<td align="left"><strong>ror</strong></td>
<td align="left">Operando da esquerda é rotacionado à direita o total de vezes indicado no operando da direita</td>
</tr>
<tr class="even">
<td align="left"><strong>select</strong></td>
<td align="left">Instrução de seleção para atribuição de valor a um sinal</td>
</tr>
<tr class="odd">
<td align="left"><strong>severity</strong></td>
<td align="left">Utilizado com o &quot;assert&quot; e &quot;report&quot;</td>
</tr>
<tr class="even">
<td align="left"><strong>signal</strong></td>
<td align="left">Declaração de que um objeto é um sinal</td>
</tr>
<tr class="odd">
<td align="left"><strong>shared</strong></td>
<td align="left">Usado para declarar objetos compartilhados</td>
</tr>
<tr class="even">
<td align="left"><strong>sla</strong></td>
<td align="left">Operador. Operando da esquerda sofre deslocamento aritmético para a esquerda o total de vezes indicado no operando da direita</td>
</tr>
<tr class="odd">
<td align="left"><strong>sll</strong></td>
<td align="left">Operador. Operando da esquerda sofre deslocamento lógico para a esquerda o total de vezes indicado no operando da direita</td>
</tr>
<tr class="even">
<td align="left"><strong>sra</strong></td>
<td align="left">Operador. Operando da esquerda sofre deslocamento aritmético para a direita o total de vezes indicado no operando da direita</td>
</tr>
<tr class="odd">
<td align="left"><strong>srl</strong></td>
<td align="left">Operador. Operando da esquerda sofre deslocamento lógico para a direita o total de vezes indicado no operando da direita</td>
</tr>
<tr class="even">
<td align="left"><strong>subtype</strong></td>
<td align="left">Declaração que restringe um tipo existente</td>
</tr>
<tr class="odd">
<td align="left"><strong>then</strong></td>
<td align="left">Parte do teste de condição &quot;if&quot;</td>
</tr>
<tr class="even">
<td align="left"><strong>to</strong></td>
<td align="left">Indicador intermediário de um intervalo: range 1 to 10</td>
</tr>
<tr class="odd">
<td align="left"><strong>transport</strong></td>
<td align="left">Característica do sinal</td>
</tr>
<tr class="even">
<td align="left"><strong>type</strong></td>
<td align="left">Declaração para criar um novo tipo</td>
</tr>
<tr class="odd">
<td align="left"><strong>unaffected</strong></td>
<td align="left">Indica, dentro de uma condicional, que um sinal não deve ser receber um novo valor</td>
</tr>
<tr class="even">
<td align="left"><strong>units</strong></td>
<td align="left">Usado para definir novos tipos de unidades</td>
</tr>
<tr class="odd">
<td align="left"><strong>until</strong></td>
<td align="left">Usado na instrução &quot;wait&quot;</td>
</tr>
<tr class="even">
<td align="left"><strong>use</strong></td>
<td align="left">Define a utilização de um pacote para a unidade de projeto atual</td>
</tr>
<tr class="odd">
<td align="left"><strong>variable</strong></td>
<td align="left">Declaração de que um objeto é uma variável</td>
</tr>
<tr class="even">
<td align="left"><strong>wait</strong></td>
<td align="left">Instrução sequencial. Também é usada na instrução &quot;case&quot;</td>
</tr>
<tr class="odd">
<td align="left"><strong>when</strong></td>
<td align="left">Usado para escolhas na instrução &quot;case&quot; e outras</td>
</tr>
<tr class="even">
<td align="left"><strong>while</strong></td>
<td align="left">Tipo da instrução &quot;loop&quot;</td>
</tr>
<tr class="odd">
<td align="left"><strong>with</strong></td>
<td align="left">Usado na instrução &quot;select&quot; para definir o sinal usado na seleção</td>
</tr>
<tr class="even">
<td align="left"><strong>xnor</strong></td>
<td align="left">Operador. &quot;XNOR&quot; entre operandos da esquerda e direita</td>
</tr>
<tr class="odd">
<td align="left"><strong>xor</strong></td>
<td align="left">Operador. &quot;XOR&quot; entre operandos da esquerda e direita</td>
</tr>
</tbody>
</table>
<p><a name="fimDocumento"></a> <a href="#inicio">Ir para o início do documento</a>.</p>
<hr />
<p><br></p>
<hr />
<hr />
<!-- FIM -->
</body>
</html>
